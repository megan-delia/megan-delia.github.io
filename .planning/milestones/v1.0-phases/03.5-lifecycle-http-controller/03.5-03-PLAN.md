---
phase: 03.5-lifecycle-http-controller
plan: 03
type: execute
wave: 3
depends_on:
  - 03.5-01
  - 03.5-02
files_modified:
  - rms-api/src/rma/lifecycle.integration.spec.ts
autonomous: true
requirements:
  - LCYC-01
  - LCYC-02
  - LCYC-05
  - LCYC-06
  - LCYC-07
  - LCYC-08
  - LCYC-09
  - LCYC-10
  - LCYC-11
  - LINE-01
  - LINE-02
  - LINE-03
  - WKFL-04

must_haves:
  truths:
    - "LCYC-01: createDraft via service creates an RMA in DRAFT status with all provided lines"
    - "LCYC-02: submit transitions DRAFT → SUBMITTED"
    - "LCYC-05: placeInfoRequired transitions SUBMITTED → INFO_REQUIRED"
    - "LCYC-06: resubmit transitions INFO_REQUIRED → SUBMITTED"
    - "LCYC-07: recordReceipt records integer receivedQty per line on APPROVED RMA; first receipt transitions to RECEIVED"
    - "LCYC-08: completeQc transitions RECEIVED → QC_COMPLETE"
    - "LCYC-09: resolve transitions QC_COMPLETE → RESOLVED after all CREDIT lines approved"
    - "LCYC-10: close transitions RESOLVED → CLOSED"
    - "LCYC-11: cancel with required reason transitions DRAFT/SUBMITTED/APPROVED → CANCELLED"
    - "LINE-01: addLine adds a new line; removeLine removes it; both blocked after SUBMITTED"
    - "LINE-02: updateLine sets disposition on a line; disposition lock triggers after qcInspectedAt set"
    - "LINE-03: receivedQty is integer per line; inspectedQty is integer per line"
    - "WKFL-04: resolve() throws when any CREDIT line lacks financeApprovedAt"
  artifacts:
    - path: "rms-api/src/rma/lifecycle.integration.spec.ts"
      provides: "Integration test coverage for all 13 Phase 3.5 requirements"
      contains: "lifecycle.integration"
  key_links:
    - from: "rms-api/src/rma/lifecycle.integration.spec.ts"
      to: "rms-api/src/rma/rma.service.ts"
      via: "NestJS TestingModule moduleRef.get(RmaService)"
      pattern: "moduleRef.get"
    - from: "rms-api/src/rma/lifecycle.integration.spec.ts"
      to: "rms-api/src/rma/rma.repository.ts"
      via: "NestJS TestingModule moduleRef.get(RmaRepository)"
      pattern: "moduleRef.get"
---

<objective>
Create `lifecycle.integration.spec.ts` — a Vitest integration test file covering all 13
Phase 3.5 requirements against a real Postgres database using the NestJS TestingModule
pattern established in Phases 2 and 3.

Purpose: These tests verify the service-layer contracts that the lifecycle controller
delegates to. They follow the exact same pattern as `workflow.integration.spec.ts`
(Phase 3) and `rma.service.integration.spec.ts` (Phase 2). Tests call service methods
directly via TestingModule — this is the established pattern for this project.

Output:
- `rms-api/src/rma/lifecycle.integration.spec.ts` — 13+ it() blocks covering all
  requirements, DB fixtures with cleanup, actor contexts for each role
</objective>

<execution_context>
@C:/Users/megan.delia/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/megan.delia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.5-lifecycle-http-controller/03.5-RESEARCH.md
@.planning/phases/03.5-lifecycle-http-controller/03.5-02-SUMMARY.md
</context>

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From rms-api/src/rma/workflow.integration.spec.ts (exact pattern to replicate):
```typescript
// @vitest-environment node
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { Test, TestingModule } from '@nestjs/testing';
import { ConfigModule } from '@nestjs/config';
import { BadRequestException } from '@nestjs/common';
import { PrismaModule } from '../prisma/prisma.module.js';
import { PrismaService } from '../prisma/prisma.service.js';
import { AuditModule } from '../audit/audit.module.js';
import { RmaModule } from './rma.module.js';
import { RmaService } from './rma.service.js';
import { RmaRepository } from './rma.repository.js';
import { RmaStatus, RmsRole, DispositionType } from '../../generated/prisma/client.js';
import { RmaActorContext } from './rma.types.js';
import { RmsUserContext } from '../users/users.service.js';

describe('Phase 3 Workflow Integration', () => {
  let moduleRef: TestingModule;
  let rmaService: RmaService;
  let rmaRepository: RmaRepository;
  let prisma: PrismaService;
  const createdRmaIds: string[] = [];
  const createdUserIds: string[] = [];

  beforeAll(async () => {
    moduleRef = await Test.createTestingModule({
      imports: [
        ConfigModule.forRoot({ isGlobal: true }),
        PrismaModule,
        AuditModule,
        RmaModule,
      ],
    }).compile();
    rmaService = moduleRef.get(RmaService);
    rmaRepository = moduleRef.get(RmaRepository);
    prisma = moduleRef.get(PrismaService);
    // ... seed branch, users, actor contexts
  });

  afterAll(async () => {
    // cleanup: delete RMAs first (FK), then users, then branches
    await prisma.rma.deleteMany({ where: { id: { in: createdRmaIds } } });
    // ...
    await moduleRef.close();
  });
});
```

From rms-api/src/rma/rma.service.integration.spec.ts (seed pattern):
```typescript
const ts = Date.now();
seedBranch = await prisma.branch.create({
  data: { name: `Integration Test Branch ${ts}`, code: `IT-${ts}` },
});
// User creation pattern:
seedUser = await prisma.rmsUser.create({
  data: {
    portalUserId: `portal-${ts}`,
    email: `agent-${ts}@test.com`,
    displayName: 'Test Agent',
    userBranchRoles: {
      create: [{ branchId: seedBranch.id, role: RmsRole.RETURNS_AGENT }],
    },
  },
});
// Actor context:
actor = {
  id: seedUser.id,
  portalUserId: seedUser.portalUserId,
  email: seedUser.email,
  role: RmsRole.RETURNS_AGENT,
  branchIds: [seedBranch.id],
  isAdmin: false,
};
```

Service method signatures (all confirmed HIGH confidence from rma.service.ts):
```typescript
createDraft(input: CreateRmaInput, actor: RmaActorContext): Promise<RmaWithLines>
submit(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
placeInfoRequired(rmaId: string, input: PlaceInfoRequiredInput, actor: RmaActorContext): Promise<RmaWithLines>
resubmit(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
recordReceipt(rmaId: string, lineId: string, input: RecordReceiptInput, actor: RmaActorContext): Promise<RmaWithLines>
completeQc(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
resolve(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
close(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
cancel(rmaId: string, input: CancelRmaInput, actor: RmaActorContext): Promise<RmaWithLines>
addLine(rmaId: string, line: LineInput, actor: RmaActorContext): Promise<RmaWithLines>
updateLine(rmaId: string, lineId: string, data: UpdateLineInput, actor: RmaActorContext): Promise<RmaWithLines>
removeLine(rmaId: string, lineId: string, actor: RmaActorContext): Promise<RmaWithLines>
approveLineCredit(rmaId: string, lineId: string, actor: RmaActorContext): Promise<RmaWithLines>
```

Repository methods (from Plan 01):
```typescript
findManyBranchScoped(user: RmsUserContext, options?): Promise<RmaWithLines[]>
findByIdBranchScoped(id: string, user: RmsUserContext): Promise<RmaWithLines | null>
```

Run command:
```
cd rms-api && npm run test:e2e -- --reporter=verbose lifecycle.integration
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create lifecycle.integration.spec.ts covering all 13 requirements</name>
  <files>rms-api/src/rma/lifecycle.integration.spec.ts</files>
  <action>
Create `rms-api/src/rma/lifecycle.integration.spec.ts` following the exact same
structure as `workflow.integration.spec.ts`. Tests call service methods and repository
methods directly via TestingModule (not HTTP requests) — this is the established pattern.

File header comment must specify:
```
Run: cd rms-api && npm run test:e2e -- --reporter=verbose lifecycle.integration
```

Required describe block: `'Phase 3.5 Lifecycle HTTP Controller Integration'`

Required actors to seed in beforeAll (one branch, multiple role users):
- agentActor: RETURNS_AGENT role
- warehouseActor: WAREHOUSE role
- qcActor: QC role
- financeActor: FINANCE role
- branchBAgentActor: RETURNS_AGENT role scoped to a SECOND branch (for isolation test)
- agentContext / branchBContext: RmsUserContext shape (for repository methods)

Required test cases (one it() block per requirement — add sub-cases inside as needed):

**LCYC-01** — `createDraft creates a Draft RMA with lines`:
  - Call `rmaService.createDraft({ branchId, lines: [{ partNumber: 'P-001', orderedQty: 3, reasonCode: 'DEFECTIVE' }] }, agentActor)`
  - Assert `result.status === RmaStatus.DRAFT`
  - Assert `result.lines.length === 1`
  - Assert `result.rmaNumber` starts with `'RMA-'`
  - Push result.id to createdRmaIds

**LCYC-02** — `submit transitions DRAFT → SUBMITTED`:
  - Create a fresh Draft RMA
  - Call `rmaService.submit(rmaId, agentActor)`
  - Assert `result.status === RmaStatus.SUBMITTED`

**LCYC-05** — `placeInfoRequired transitions SUBMITTED → INFO_REQUIRED`:
  - Create draft, submit
  - Call `rmaService.placeInfoRequired(rmaId, { infoRequestNote: 'Need serial numbers' }, agentActor)`
  - Assert `result.status === RmaStatus.INFO_REQUIRED`

**LCYC-06** — `resubmit transitions INFO_REQUIRED → SUBMITTED`:
  - Create draft, submit, place info-required
  - Call `rmaService.resubmit(rmaId, agentActor)`
  - Assert `result.status === RmaStatus.SUBMITTED`

**LCYC-07 + LINE-03** — `recordReceipt records integer receivedQty per line`:
  - Create draft, submit; call rmaService.approve() using a managerActor (BRANCH_MANAGER)
    to reach APPROVED status first — need a managerActor seeded
  - Seed managerActor: BRANCH_MANAGER role, same branch
  - Call `rmaService.recordReceipt(rmaId, lineId, { receivedQty: 2 }, warehouseActor)`
  - Assert `result.lines[0].receivedQty === 2`
  - Assert `result.status === RmaStatus.RECEIVED` (first receipt transitions)

**LCYC-08** — `completeQc transitions RECEIVED → QC_COMPLETE`:
  - Advance RMA to RECEIVED (draft → submit → approve → receive)
  - Call `rmaService.completeQc(rmaId, qcActor)`
  - Assert `result.status === RmaStatus.QC_COMPLETE`

**LCYC-09 + WKFL-04** — `resolve: Finance gate blocks then allows`:
  - Advance RMA to QC_COMPLETE with a CREDIT disposition line
  - Attempt `rmaService.resolve(rmaId, financeActor)` → expect BadRequestException
    (Finance gate: unapproved credit line blocks resolve)
  - Call `rmaService.approveLineCredit(rmaId, lineId, financeActor)` to approve
  - Call `rmaService.resolve(rmaId, financeActor)` again → assert RESOLVED
  - This is the key WKFL-04 proof: resolve() is blocked until financeApprovedAt is set

**LCYC-10** — `close transitions RESOLVED → CLOSED`:
  - Advance RMA to RESOLVED
  - Call `rmaService.close(rmaId, agentActor)`
  - Assert `result.status === RmaStatus.CLOSED`

**LCYC-11** — `cancel with required reason`:
  - Create draft
  - Call `rmaService.cancel(rmaId, { cancellationReason: 'Customer withdrew' }, agentActor)`
  - Assert `result.status === RmaStatus.CANCELLED`
  - Also test cancel without reason throws BadRequestException (missing required field)

**LINE-01** — `addLine and removeLine CRUD`:
  - Create draft with 1 line
  - Call `rmaService.addLine(rmaId, { partNumber: 'P-002', orderedQty: 1, reasonCode: 'WRONG_ITEM' }, agentActor)`
  - Assert returned RMA has 2 lines
  - Get lineId of P-002; call `rmaService.removeLine(rmaId, lineId, agentActor)`
  - Assert returned RMA has 1 line

**LINE-02** — `updateLine sets disposition; disposition lock after qcInspectedAt`:
  - Create draft with 1 line (no disposition)
  - Call `rmaService.updateLine(rmaId, lineId, { disposition: 'CREDIT' }, agentActor)`
  - Assert `result.lines[0].disposition === DispositionType.CREDIT`
  - Advance to RECEIVED; set qcInspectedAt via `prisma.rmaLine.update` to simulate QC lock
  - Attempt `rmaService.updateLine(rmaId, lineId, { disposition: 'SCRAP' }, agentActor)`
  - Assert throws BadRequestException (disposition locked after inspection)

**LINE-03** — `integer quantity tracking` (covered by LCYC-07 receipt test above):
  - Add a sub-assertion within the LCYC-07 test confirming inspectedQty starts at 0
  - After recording QC inspection (recordQcInspection call), assert inspectedQty === N

**Branch isolation (FOUND-03)** — `findByIdBranchScoped returns null for cross-branch`:
  - Create RMA in branchA
  - Call `rmaRepository.findByIdBranchScoped(rmaId, branchBContext)`
  - Assert result is null
  - Call `rmaRepository.findManyBranchScoped(branchBContext)`
  - Assert returned list does not contain the branchA RMA

Helper function: Create `async function advanceToDraftApproved(prisma, rmaService, agentActor, managerActor, branchId)` that creates a draft, submits it, and approves it — used by multiple tests. Inline this if 3+ tests need it.

Cleanup: afterAll must delete all created RMAs (via prisma.rma.deleteMany where id in createdRmaIds), then all created users (prisma.rmsUser.deleteMany), then branches (prisma.branch.deleteMany). Order matters for FK constraints.
  </action>
  <verify>
    <automated>cd "C:/Users/megan.delia/OneDrive - Master Electronics/Desktop/Claude Workshop/rms-api" && npm run build 2>&1 | tail -5</automated>
  </verify>
  <done>
`lifecycle.integration.spec.ts` exists and compiles with 0 TypeScript errors via
`npm run build`. The file contains `describe('Phase 3.5 Lifecycle HTTP Controller
Integration'` and at least 13 `it()` blocks. All required requirement IDs (LCYC-01
through LCYC-11, LINE-01, LINE-02, LINE-03, WKFL-04) are referenced in test names
or comments.
  </done>
</task>

</tasks>

<verification>
- `npm run build` exits 0 — spec file compiles cleanly
- `lifecycle.integration.spec.ts` exists and has describe block named 'Phase 3.5 Lifecycle HTTP Controller Integration'
- At least 13 it() blocks are present (one per requirement minimum)
- WKFL-04 test demonstrates the two-step: resolve() throws → approveLineCredit() → resolve() succeeds
- Branch isolation test is present using branchBContext + findByIdBranchScoped
- beforeAll seeds all required actors (agent, warehouse, qc, finance, manager, branchB)
- afterAll cleans up all created records in FK-safe order (RMAs → users → branches)
- Run command in header comment: `npm run test:e2e -- --reporter=verbose lifecycle.integration`
</verification>

<success_criteria>
- Integration spec compiles and has full coverage of all 13 Phase 3.5 requirements
- Each requirement maps to at least one it() block with a descriptive name
- WKFL-04 Finance gate test explicitly demonstrates: blocked-before-approval AND
  succeeds-after-approval in a single test flow
- Branch isolation test confirms findByIdBranchScoped returns null for out-of-scope RMAs
- Test file follows the exact same structure as workflow.integration.spec.ts (same imports,
  same TestingModule setup, same cleanup pattern)
</success_criteria>

<output>
After completion, create `.planning/phases/03.5-lifecycle-http-controller/03.5-03-SUMMARY.md`
</output>
