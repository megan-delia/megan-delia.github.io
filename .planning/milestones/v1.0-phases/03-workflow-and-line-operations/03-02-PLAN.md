---
phase: 03-workflow-and-line-operations
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - rms-api/src/rma/rma.service.ts
  - rms-api/src/rma/rma.repository.ts
autonomous: true
requirements:
  - WKFL-01
  - WKFL-02
  - WKFL-03
  - WKFL-04
  - WKFL-05
  - LINE-04

must_haves:
  truths:
    - "RmaService has contest(), overturn(), uphold() methods implementing the CONTESTED state flow"
    - "RmaService has splitLine() that conserves quantity and replaces original line atomically"
    - "RmaService has approveLineCredit() and the resolve() guard blocks if any credit line is unapproved"
    - "RmaService.updateLine() clears Finance approval when disposition changes away from CREDIT"
    - "RmaService.recordQcInspection() accepts and stores qcPass, qcFindings, qcDispositionRecommendation"
    - "RmaRepository has findForApprovalQueue() and findCreditApprovalLines() methods"
    - "TypeScript build passes with zero errors"
  artifacts:
    - path: "rms-api/src/rma/rma.service.ts"
      provides: "All Phase 3 service methods"
      exports: ["contest", "overturn", "uphold", "splitLine", "approveLineCredit"]
    - path: "rms-api/src/rma/rma.repository.ts"
      provides: "Queue query methods"
      exports: ["findForApprovalQueue", "findCreditApprovalLines"]
  key_links:
    - from: "rms-api/src/rma/rma.service.ts"
      to: "rms-api/src/rma/rma-lifecycle.ts"
      via: "assertValidTransition(rma.status, RmaStatus.CONTESTED)"
      pattern: "assertValidTransition.*CONTESTED"
    - from: "rms-api/src/rma/rma.service.ts"
      to: "rms-api/src/rma/rma.repository.ts"
      via: "rmaRepository.findById() for all service methods"
      pattern: "rmaRepository\\.findById"
    - from: "rms-api/src/rma/rma.service.ts"
      to: "rms-api/src/audit/audit.service.ts"
      via: "auditService.logEvent(tx, ...) inside every $transaction"
      pattern: "logEvent\\(tx"
---

<objective>
Extend RmaService with all Phase 3 service methods and extend RmaRepository with queue query methods. This is pure service/repository code — no controllers yet. All methods follow the established Phase 2 patterns: fetch → validate → $transaction(write + audit).

Purpose: Service layer is the single source of truth for all business logic. Controllers (Plan 03) will be thin wrappers that call these methods.
Output: Extended rma.service.ts with 5 new methods + modified resolve()/updateLine()/recordQcInspection(); extended rma.repository.ts with 2 new query methods.
</objective>

<execution_context>
@C:/Users/megan.delia/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/megan.delia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-workflow-and-line-operations/03-CONTEXT.md
@.planning/phases/03-workflow-and-line-operations/03-RESEARCH.md

@.planning/phases/02-core-rma-lifecycle/02-03-SUMMARY.md
@.planning/phases/02-core-rma-lifecycle/02-04-SUMMARY.md
@.planning/phases/03-workflow-and-line-operations/03-01-SUMMARY.md

<interfaces>
<!-- Established Phase 2 patterns the executor MUST follow exactly -->

Phase 2 atomic service method pattern (every method uses this structure):
```typescript
async methodName(rmaId: string, input: SomeInput, actor: RmaActorContext): Promise<RmaWithLines> {
  // 1. Fetch OUTSIDE transaction
  const rma = await this.rmaRepository.findById(rmaId);
  if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);

  // 2. Validate transition
  assertValidTransition(rma.status, RmaStatus.TARGET_STATUS);

  // 3. Business guards (input validation, state checks)
  if (!input.someField || input.someField.trim().length === 0) {
    throw new BadRequestException('Field is required');
  }

  // 4. Transaction: DB write + audit log atomically
  return this.prisma.$transaction(async (tx) => {
    await this.rmaRepository.updateStatus(tx, rmaId, RmaStatus.TARGET_STATUS);
    // OR: await this.rmaRepository.updateRma(tx, rmaId, { status: ..., field: ... });
    await this.auditService.logEvent(tx, {
      rmaId, actorId: actor.id, actorRole: actor.role,
      action: AuditAction.SOME_ACTION,
      fromStatus: rma.status, toStatus: RmaStatus.TARGET_STATUS,
      newValue: { ... },
    });
    return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
  });
}
```

Constructor injection — ALL three params MUST use @Inject():
```typescript
constructor(
  @Inject(PrismaService)   private readonly prisma: PrismaService,
  @Inject(AuditService)    private readonly auditService: AuditService,
  @Inject(RmaRepository)   private readonly rmaRepository: RmaRepository,
) {}
```

Phase 2 LINE_EDITABLE_STATUSES guard (used in addLine/updateLine/removeLine — same guard for splitLine):
```typescript
const LINE_EDITABLE_STATUSES: RmaStatus[] = [RmaStatus.DRAFT, RmaStatus.INFO_REQUIRED];
if (!LINE_EDITABLE_STATUSES.includes(rma.status)) {
  throw new BadRequestException(`Cannot mutate lines on an RMA in ${rma.status} status`);
}
```

RmaRepository.updateRma() signature from Phase 2 (accepts partial Rma fields):
```typescript
async updateRma(
  tx: Prisma.TransactionClient | PrismaService,
  rmaId: string,
  data: Partial<Prisma.RmaUpdateInput>,
): Promise<void>
```

branchScopeWhere(user) from Phase 1 users.service.ts:
```typescript
// Returns: { branchId: { in: user.branchIds } } for non-admin
// Returns: {}  for admin (sees all)
export function branchScopeWhere(user: RmsUserContext): { branchId?: { in: string[] } }
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add contest/overturn/uphold/splitLine/approveLineCredit to RmaService and extend resolve()/updateLine()/recordQcInspection()</name>
  <files>
    rms-api/src/rma/rma.service.ts
  </files>
  <action>
    Read the current rma.service.ts to understand the exact file structure and import list. Then add the following methods and modify the specified existing methods.

    **NEW METHOD: contest() — WKFL-02**
    ```typescript
    async contest(rmaId: string, input: ContestInput, actor: RmaActorContext): Promise<RmaWithLines> {
      if (!input.disputeReason || input.disputeReason.trim().length === 0) {
        throw new BadRequestException('Dispute reason is required');
      }
      const rma = await this.rmaRepository.findById(rmaId);
      if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);
      // "One contest per RMA" — service-layer rule (state machine alone is insufficient)
      // rma.contestedAt is set on the FIRST contest and never cleared
      if (rma.contestedAt !== null && rma.contestedAt !== undefined) {
        throw new BadRequestException('This RMA has already been contested once and cannot be contested again');
      }
      assertValidTransition(rma.status, RmaStatus.CONTESTED);
      return this.prisma.$transaction(async (tx) => {
        await this.rmaRepository.updateRma(tx, rmaId, {
          status: RmaStatus.CONTESTED,
          disputeReason: input.disputeReason.trim(),
          contestedAt: new Date(),
        });
        await this.auditService.logEvent(tx, {
          rmaId, actorId: actor.id, actorRole: actor.role,
          action: AuditAction.RMA_CONTESTED,
          fromStatus: rma.status, toStatus: RmaStatus.CONTESTED,
          newValue: { disputeReason: input.disputeReason.trim() },
        });
        return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
      });
    }
    ```

    **NEW METHOD: overturn() — WKFL-03 (CONTESTED → APPROVED)**
    ```typescript
    async overturn(rmaId: string, input: OverturnInput, actor: RmaActorContext): Promise<RmaWithLines> {
      if (!input.resolutionNote || input.resolutionNote.trim().length === 0) {
        throw new BadRequestException('Resolution note is required');
      }
      const rma = await this.rmaRepository.findById(rmaId);
      if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);
      assertValidTransition(rma.status, RmaStatus.APPROVED);
      return this.prisma.$transaction(async (tx) => {
        await this.rmaRepository.updateRma(tx, rmaId, {
          status: RmaStatus.APPROVED,
          contestResolutionNote: input.resolutionNote.trim(),
        });
        await this.auditService.logEvent(tx, {
          rmaId, actorId: actor.id, actorRole: actor.role,
          action: AuditAction.RMA_APPROVED,
          fromStatus: rma.status, toStatus: RmaStatus.APPROVED,
          newValue: { resolutionNote: input.resolutionNote.trim(), overturned: true },
        });
        return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
      });
    }
    ```

    **NEW METHOD: uphold() — WKFL-03 (CONTESTED → CLOSED)**
    ```typescript
    async uphold(rmaId: string, input: UpholdInput, actor: RmaActorContext): Promise<RmaWithLines> {
      if (!input.resolutionNote || input.resolutionNote.trim().length === 0) {
        throw new BadRequestException('Resolution note is required');
      }
      const rma = await this.rmaRepository.findById(rmaId);
      if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);
      assertValidTransition(rma.status, RmaStatus.CLOSED);
      return this.prisma.$transaction(async (tx) => {
        await this.rmaRepository.updateRma(tx, rmaId, {
          status: RmaStatus.CLOSED,
          contestResolutionNote: input.resolutionNote.trim(),
        });
        await this.auditService.logEvent(tx, {
          rmaId, actorId: actor.id, actorRole: actor.role,
          action: AuditAction.RMA_CLOSED,
          fromStatus: rma.status, toStatus: RmaStatus.CLOSED,
          newValue: { resolutionNote: input.resolutionNote.trim(), upheld: true },
        });
        return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
      });
    }
    ```

    **NEW METHOD: splitLine() — LINE-04**
    ```typescript
    async splitLine(
      rmaId: string,
      lineId: string,
      splits: SplitLineInput[],
      actor: RmaActorContext,
    ): Promise<RmaWithLines> {
      // Guard: minimum 2 lines required
      if (splits.length < 2) {
        throw new BadRequestException('Split must produce at least 2 lines');
      }
      const rma = await this.rmaRepository.findById(rmaId);
      if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);
      // Guard: LINE_EDITABLE_STATUSES (same guard as addLine/updateLine/removeLine)
      if (!LINE_EDITABLE_STATUSES.includes(rma.status)) {
        throw new BadRequestException(
          `Cannot split lines on an RMA in ${rma.status} status — lines are locked after submission`
        );
      }
      const line = rma.lines.find((l) => l.id === lineId);
      if (!line) throw new NotFoundException(`Line ${lineId} not found on RMA ${rmaId}`);
      // Guard: quantity conservation — sum of splits must equal original orderedQty exactly
      const totalSplitQty = splits.reduce((sum, s) => sum + s.orderedQty, 0);
      if (totalSplitQty !== line.orderedQty) {
        throw new BadRequestException(
          `Split quantities must sum to ${line.orderedQty} (original ordered qty); got ${totalSplitQty}`
        );
      }
      return this.prisma.$transaction(async (tx) => {
        // Delete original line
        await tx.rmaLine.delete({ where: { id: lineId } });
        // Create replacement lines
        await tx.rmaLine.createMany({
          data: splits.map((s) => ({
            rmaId,
            partNumber: s.partNumber,
            orderedQty: s.orderedQty,
            reasonCode: s.reasonCode,
            disposition: s.disposition ?? null,
            receivedQty: 0,
            inspectedQty: 0,
          })),
        });
        await this.auditService.logEvent(tx, {
          rmaId,
          rmaLineId: lineId,
          actorId: actor.id,
          actorRole: actor.role,
          action: AuditAction.LINE_SPLIT,
          oldValue: { partNumber: line.partNumber, orderedQty: line.orderedQty, splitInto: splits.length },
          newValue: { splitLines: splits.map((s) => ({ partNumber: s.partNumber, orderedQty: s.orderedQty })) },
        });
        // createMany returns { count: N } — always re-fetch to return RmaWithLines
        return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
      });
    }
    ```

    **NEW METHOD: approveLineCredit() — WKFL-04**
    ```typescript
    async approveLineCredit(
      rmaId: string,
      lineId: string,
      actor: RmaActorContext,
    ): Promise<RmaWithLines> {
      const rma = await this.rmaRepository.findById(rmaId);
      if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);
      const line = rma.lines.find((l) => l.id === lineId);
      if (!line) throw new NotFoundException(`Line ${lineId} not found on RMA ${rmaId}`);
      if (line.disposition !== DispositionType.CREDIT) {
        throw new BadRequestException(`Line ${lineId} does not have CREDIT disposition — Finance approval not applicable`);
      }
      return this.prisma.$transaction(async (tx) => {
        await tx.rmaLine.update({
          where: { id: lineId },
          data: {
            financeApprovedAt: new Date(),
            financeApprovedById: actor.id,
          },
        });
        await this.auditService.logEvent(tx, {
          rmaId,
          rmaLineId: lineId,
          actorId: actor.id,
          actorRole: actor.role,
          action: AuditAction.FINANCE_APPROVED,
          newValue: { lineId, disposition: 'CREDIT', approvedBy: actor.id },
        });
        return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
      });
    }
    ```

    **MODIFY EXISTING: resolve() — add Finance approval hard-block guard (WKFL-04)**
    In the existing `resolve()` method, BEFORE the `this.prisma.$transaction(...)` call, add:
    ```typescript
    // Finance approval gate — all CREDIT lines must be approved before resolving
    const unapprovedCreditLines = rma.lines.filter(
      (l) => l.disposition === DispositionType.CREDIT && (l.financeApprovedAt === null || l.financeApprovedAt === undefined)
    );
    if (unapprovedCreditLines.length > 0) {
      throw new BadRequestException(
        `Cannot resolve — ${unapprovedCreditLines.length} credit line(s) awaiting Finance approval`
      );
    }
    ```

    **MODIFY EXISTING: updateLine() — clear Finance approval on non-CREDIT disposition change (Pitfall 3)**
    In the existing `updateLine()` method, inside the `this.prisma.$transaction(...)` callback, when calling `tx.rmaLine.update()`:
    If `data.disposition` is set AND is not `DispositionType.CREDIT`, add `financeApprovedAt: null, financeApprovedById: null` to the update data. Condition:
    ```typescript
    const clearFinanceApproval =
      data.disposition !== undefined &&
      data.disposition !== DispositionType.CREDIT;
    // Add to the update data object:
    ...(clearFinanceApproval ? { financeApprovedAt: null, financeApprovedById: null } : {}),
    ```

    **MODIFY EXISTING: recordQcInspection() — extend to accept Phase 3 QC result fields (WKFL-05)**
    Update the method signature to accept the extended `RecordQcInspectionInput` (which now includes `qcPass`, `qcFindings`, `qcDispositionRecommendation`). Inside the `tx.rmaLine.update()` call, add:
    ```typescript
    ...(input.qcPass !== undefined ? { qcPass: input.qcPass } : {}),
    ...(input.qcFindings !== undefined ? { qcFindings: input.qcFindings } : {}),
    ...(input.qcDispositionRecommendation !== undefined
      ? { qcDispositionRecommendation: input.qcDispositionRecommendation }
      : {}),
    ```

    **Imports to add at the top of rma.service.ts (if not already present):**
    - `ContestInput, OverturnInput, UpholdInput, SplitLineInput, ApproveLineCreditInput` from `./rma.types.js`
    - `DispositionType` from `../../../generated/prisma/client.js` (ESM pattern consistent with existing imports)
  </action>
  <verify>
    Run: `cd rms-api && npm run build`
    Expected: exits 0, "Found 0 errors."

    Run: `cd rms-api && grep -n "contest\|overturn\|uphold\|splitLine\|approveLineCredit\|unapprovedCreditLines\|clearFinanceApproval\|qcFindings" src/rma/rma.service.ts`
    Expected: All 8 terms found in the file.

    Run: `cd rms-api && npm test -- --testPathPatterns=rma.service.spec`
    Expected: 41/41 tests pass (no regression in Phase 2 unit tests).
  </verify>
  <done>All 5 new service methods present. resolve() has Finance approval guard. updateLine() clears Finance approval on non-CREDIT disposition change. recordQcInspection() accepts QC result fields. npm run build exits 0. 41 Phase 2 unit tests still passing.</done>
</task>

<task type="auto">
  <name>Task 2: Add findForApprovalQueue and findCreditApprovalLines to RmaRepository</name>
  <files>
    rms-api/src/rma/rma.repository.ts
  </files>
  <action>
    Read the current rma.repository.ts to understand the existing method signatures and import list. Then add two new query methods.

    **NEW METHOD: findForApprovalQueue() — WKFL-01**
    ```typescript
    async findForApprovalQueue(
      user: RmsUserContext,
      options?: {
        branchId?: string;
        status?: RmaStatus;
        take?: number;
        skip?: number;
      },
    ): Promise<ApprovalQueueItem[]> {
      // Status filter: both SUBMITTED and CONTESTED unless caller requests one
      const statusFilter = options?.status
        ? [options.status]
        : [RmaStatus.SUBMITTED, RmaStatus.CONTESTED];

      // Branch filter: always start from branchScopeWhere(user) for ownership enforcement
      // If caller provides ?branchId=, validate it is within the user's branches before narrowing
      const userBranchFilter = branchScopeWhere(user);
      const branchFilter =
        options?.branchId && (user.branchIds.includes(options.branchId) || user.branchIds.length === 0)
          ? { branchId: options.branchId }   // narrowed to one branch (user owns it)
          : userBranchFilter;                // all user's branches (or admin: no filter)

      const rows = await this.prisma.rma.findMany({
        where: {
          ...branchFilter,
          status: { in: statusFilter },
        },
        orderBy: { createdAt: 'asc' },      // FIFO — oldest first
        take: options?.take ?? 50,
        skip: options?.skip ?? 0,
        select: {
          id: true,
          rmaNumber: true,
          status: true,
          createdAt: true,
          customerId: true,
          submittedById: true,
          lines: { select: { orderedQty: true } },
          _count: { select: { lines: true } },
        },
      });

      // Map to ApprovalQueueItem shape (user lookup deferred — use submittedById for now)
      return rows.map((r) => ({
        id: r.id,
        rmaNumber: r.rmaNumber,
        status: r.status as string,
        createdAt: r.createdAt,
        customerId: r.customerId,
        submittedByName: null,           // populated by controller via UsersService if needed
        submittedByEmail: null,
        lineCount: r._count.lines,
        totalOrderedQty: r.lines.reduce((sum, l) => sum + l.orderedQty, 0),
      }));
    }
    ```

    NOTE: The full user name/email join requires either a Prisma relation join on the User model or a secondary lookup. For v1, returning `submittedByName: null` and `submittedByEmail: null` is acceptable — the `rmaNumber`, `customerId`, `createdAt`, `lineCount`, and `totalOrderedQty` are the primary queue fields. If the Rma model already has a `submittedBy` relation pointing to the User model, use:
    ```typescript
    submittedBy: { select: { displayName: true, email: true } }
    ```
    in the select and map to `submittedByName: r.submittedBy?.displayName ?? null`. Check the schema — if the relation exists, use it.

    **NEW METHOD: findCreditApprovalLines() — WKFL-04**
    ```typescript
    async findCreditApprovalLines(
      user: RmsUserContext,
      options?: { take?: number; skip?: number },
    ): Promise<CreditApprovalQueueItem[]> {
      const rows = await this.prisma.rmaLine.findMany({
        where: {
          disposition: DispositionType.CREDIT,
          financeApprovedAt: null,
          rma: {
            status: RmaStatus.QC_COMPLETE,
            ...branchScopeWhere(user),    // Finance users also scoped to their branch(es)
          },
        },
        orderBy: { rma: { createdAt: 'asc' } },
        take: options?.take ?? 100,
        skip: options?.skip ?? 0,
        select: {
          id: true,
          partNumber: true,
          orderedQty: true,
          disposition: true,
          rma: {
            select: {
              id: true,
              rmaNumber: true,
              status: true,
            },
          },
        },
      });

      return rows.map((l) => ({
        rmaId: l.rma.id,
        rmaNumber: l.rma.rmaNumber,
        lineId: l.id,
        partNumber: l.partNumber,
        orderedQty: l.orderedQty,
        disposition: l.disposition as string,
        rmaStatus: l.rma.status as string,
      }));
    }
    ```

    **Imports to add at the top of rma.repository.ts (if not already present):**
    - `ApprovalQueueItem, CreditApprovalQueueItem` from `./rma.types.js`
    - `RmsUserContext` from `../users/users.service.js`
    - `branchScopeWhere` from `../users/users.service.js`
    - `DispositionType` from `../../../generated/prisma/client.js`
    - `RmaStatus` from `../../../generated/prisma/client.js` (or enums.js — check existing imports)
  </action>
  <verify>
    Run: `cd rms-api && npm run build`
    Expected: exits 0, "Found 0 errors."

    Run: `cd rms-api && grep -n "findForApprovalQueue\|findCreditApprovalLines\|branchScopeWhere" src/rma/rma.repository.ts`
    Expected: All 3 terms found.

    Run: `cd rms-api && npm test -- --testPathPatterns=rma.service.spec`
    Expected: 41/41 tests pass (repository changes must not break unit tests).
  </verify>
  <done>findForApprovalQueue() and findCreditApprovalLines() present in RmaRepository. Both use branchScopeWhere() for ownership enforcement. npm run build exits 0. Phase 2 unit tests still green.</done>
</task>

</tasks>

<verification>
1. `cd rms-api && npm run build` — 0 TypeScript errors
2. `cd rms-api && npm test -- --testPathPatterns=rma.service.spec` — 41/41 pass (regression check)
3. `cd rms-api && grep "async contest\|async overturn\|async uphold\|async splitLine\|async approveLineCredit" src/rma/rma.service.ts` — all 5 methods present
4. `cd rms-api && grep "async findForApprovalQueue\|async findCreditApprovalLines" src/rma/rma.repository.ts` — both methods present
5. `cd rms-api && grep "unapprovedCreditLines" src/rma/rma.service.ts` — Finance resolve guard present
</verification>

<success_criteria>
- 5 new service methods: contest, overturn, uphold, splitLine, approveLineCredit
- resolve() has Finance approval hard-block guard
- updateLine() clears Finance approval on non-CREDIT disposition change
- recordQcInspection() accepts qcPass, qcFindings, qcDispositionRecommendation
- 2 new repository methods: findForApprovalQueue, findCreditApprovalLines (both use branchScopeWhere)
- npm run build exits 0
- 41 Phase 2 Jest unit tests still passing
</success_criteria>

<output>
After completion, create `.planning/phases/03-workflow-and-line-operations/03-02-SUMMARY.md`
</output>
