---
phase: 03-workflow-and-line-operations
plan: 04
type: tdd
wave: 4
depends_on:
  - 03-01
  - 03-02
  - 03-03
files_modified:
  - rms-api/src/rma/workflow.integration.spec.ts
autonomous: true
requirements:
  - WKFL-01
  - WKFL-02
  - WKFL-03
  - WKFL-04
  - WKFL-05
  - LINE-04

must_haves:
  truths:
    - "WKFL-01 verified: approval queue returns only SUBMITTED/CONTESTED RMAs in the manager's branch, sorted oldest-first"
    - "WKFL-02 verified: customer can contest a REJECTED RMA; second contest on same RMA throws"
    - "WKFL-03 verified: overturn transitions CONTESTED → APPROVED; uphold transitions CONTESTED → CLOSED"
    - "WKFL-04 verified: Finance approves credit line; resolve() blocked if credit line unapproved; Finance approval cleared when disposition changes"
    - "WKFL-05 verified: QC inspection records qcPass/qcFindings/qcDispositionRecommendation per line"
    - "LINE-04 verified: split conserves quantity; split produces independent lines; quantity mismatch throws; split in SUBMITTED status throws"
    - "RBAC verified: wrong-role caller on queue endpoints receives 403"
    - "Cross-branch isolation verified: approval queue does not leak another branch's RMAs"
  artifacts:
    - path: "rms-api/src/rma/workflow.integration.spec.ts"
      provides: "Vitest integration tests for all 6 Phase 3 requirements"
      min_lines: 150
  key_links:
    - from: "rms-api/src/rma/workflow.integration.spec.ts"
      to: "rms-api/src/rma/rma.service.ts"
      via: "Direct service method calls (same pattern as Phase 2 integration tests)"
      pattern: "rmaService\\."
    - from: "rms-api/src/rma/workflow.integration.spec.ts"
      to: "rms-api/src/rma/rma.repository.ts"
      via: "Direct repository calls for queue verification"
      pattern: "rmaRepository\\."
---

<objective>
Write Vitest integration tests that verify all 6 Phase 3 requirements against the real Postgres database. These tests follow the identical pattern established in Phase 2 plan 05 — direct service/repository calls, real DB, Prisma transactions for cleanup.

Purpose: Establish the regression baseline for Phase 3. Tests prove the complete implementation end-to-end, catching any integration issues between schema, service, and repository layers.
Output: workflow.integration.spec.ts with tests covering all 6 Phase 3 requirement IDs. Tests are compile-clean and ready to run with Docker.
</objective>

<execution_context>
@C:/Users/megan.delia/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/megan.delia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-workflow-and-line-operations/03-CONTEXT.md
@.planning/phases/03-workflow-and-line-operations/03-RESEARCH.md

@.planning/phases/02-core-rma-lifecycle/02-05-SUMMARY.md
@.planning/phases/03-workflow-and-line-operations/03-01-SUMMARY.md
@.planning/phases/03-workflow-and-line-operations/03-02-SUMMARY.md
@.planning/phases/03-workflow-and-line-operations/03-03-SUMMARY.md

<interfaces>
<!-- Phase 2 integration test patterns — replicate exactly -->

File header pattern (from rma.service.integration.spec.ts):
```typescript
// @vitest-environment node
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { PrismaClient, RmaStatus, RmsRole, DispositionType } from '../../generated/prisma/client.js';
// Integration test imports use client.js (ESM-native), NOT enums.js
```

Test module setup pattern (from Phase 2 — use NestJS TestingModule to wire real DI):
```typescript
import { Test } from '@nestjs/testing';
import { RmaModule } from './rma.module.js';
import { ConfigModule } from '@nestjs/config';
// ... other module imports

let rmaService: RmaService;
let rmaRepository: RmaRepository;
let prisma: PrismaClient;

beforeAll(async () => {
  const moduleRef = await Test.createTestingModule({
    imports: [ConfigModule.forRoot({ isGlobal: true }), RmaModule, /* required modules */],
  }).compile();

  rmaService = moduleRef.get<RmaService>(RmaService);
  rmaRepository = moduleRef.get<RmaRepository>(RmaRepository);
  prisma = new PrismaClient();
  await prisma.$connect();
});
```

Cleanup pattern (FK-safe order from Phase 2):
```typescript
afterAll(async () => {
  // Delete in FK-safe order: audit → line → rma → userBranchRole → user → branch
  if (createdRmaIds.length > 0) {
    await prisma.auditEvent.deleteMany({ where: { rmaId: { in: createdRmaIds } } });
    await prisma.rmaLine.deleteMany({ where: { rmaId: { in: createdRmaIds } } });
    await prisma.rma.deleteMany({ where: { id: { in: createdRmaIds } } });
  }
  // Clean up users, branches created for tests
  await prisma.$disconnect();
});
```

Actor context shape used in all Phase 2 service calls:
```typescript
const agentActor: RmaActorContext = { id: agentUser.id, role: 'RETURNS_AGENT', branchIds: [branch.id] };
const managerActor: RmaActorContext = { id: managerUser.id, role: 'BRANCH_MANAGER', branchIds: [branch.id] };
const customerActor: RmaActorContext = { id: customerUser.id, role: 'CUSTOMER', branchIds: [] };
const financeActor: RmaActorContext = { id: financeUser.id, role: 'FINANCE', branchIds: [branch.id] };
const qcActor: RmaActorContext = { id: qcUser.id, role: 'QC', branchIds: [branch.id] };
```
</interfaces>
</context>

<feature>
  <name>Phase 3 workflow integration tests</name>
  <files>rms-api/src/rma/workflow.integration.spec.ts</files>
  <behavior>
    Verify all 6 Phase 3 requirement IDs against real Postgres DB:

    **WKFL-01: Approval queue**
    - Setup: Create two RMAs in SUBMITTED status (branch A), one in APPROVED (different status, should not appear), one SUBMITTED at branch B (different branch, should not appear for branch A manager)
    - Test 1: findForApprovalQueue(branchAManager) returns only branch A SUBMITTED RMAs, oldest first
    - Test 2: findForApprovalQueue(branchAManager, { status: 'CONTESTED' }) returns empty when no CONTESTED RMAs
    - Test 3: After contesting one rejected RMA, approval queue includes it in CONTESTED status

    **WKFL-02: Contest flow**
    - Setup: Create RMA → submit → reject (reaches REJECTED status)
    - Test 1: contest(rmaId, { disputeReason: 'Valid reason' }, customerActor) → RMA status is CONTESTED, contestedAt is set
    - Test 2: contest(same rmaId again, ...) → throws BadRequestException ("already been contested once")
    - Test 3: contest with empty disputeReason → throws BadRequestException

    **WKFL-03: Overturn and uphold**
    - Setup: Create RMA → submit → reject → contest (reaches CONTESTED)
    - Test 1 (overturn): overturn(rmaId, { resolutionNote: 'Overturning' }, managerActor) → status is APPROVED, contestResolutionNote is set
    - Test 2 (uphold): Create a separate CONTESTED RMA → uphold(rmaId, { resolutionNote: 'Upholding' }, managerActor) → status is CLOSED
    - Test 3: overturn with empty resolutionNote → throws BadRequestException

    **WKFL-04: Finance approval gate**
    - Setup: Create RMA with CREDIT disposition line → progress to QC_COMPLETE status
    - Test 1: approveLineCredit(rmaId, lineId, financeActor) → line.financeApprovedAt is set
    - Test 2: resolve() before Finance approval → throws BadRequestException ("awaiting Finance approval")
    - Test 3: resolve() after Finance approval → succeeds (RMA reaches RESOLVED)
    - Test 4: Update line disposition from CREDIT to SCRAP → financeApprovedAt is cleared on the line

    **WKFL-05: QC inspection recording**
    - Setup: Create RMA → progress to RECEIVED status
    - Test 1: recordQcInspection(rmaId, { lineId, inspectedQty: 2, qcPass: true, qcFindings: 'No damage', qcDispositionRecommendation: 'CREDIT' }, qcActor)
      → line.inspectedQty = 2, line.qcPass = true, line.qcFindings = 'No damage', line.qcDispositionRecommendation = 'CREDIT'
    - Test 2: recordQcInspection with qcPass: false and qcFindings → persists correctly

    **LINE-04: Line split**
    - Setup: Create RMA in DRAFT with one line (partNumber: 'P001', orderedQty: 10)
    - Test 1: splitLine(rmaId, lineId, [{ partNumber: 'P001', orderedQty: 6, reasonCode: 'R1' }, { partNumber: 'P001', orderedQty: 4, reasonCode: 'R2' }], agentActor)
      → original line is gone, two new lines exist with qty 6 and 4, total qty = 10
    - Test 2: split with quantities that don't sum to original → throws BadRequestException
    - Test 3: split with only 1 split line → throws BadRequestException ("at least 2 lines")
    - Test 4: submit the RMA first, then attempt split → throws BadRequestException (lines locked)

    **Cross-branch isolation (WKFL-01 data ownership)**
    - Create RMA at branch B, manager for branch A calls findForApprovalQueue → branch B RMA does NOT appear
  </behavior>
  <implementation>
    Pattern: Follow rma.service.integration.spec.ts (Phase 2) exactly.
    - File header: `// @vitest-environment node`
    - Imports: from `../../generated/prisma/client.js` (ESM pattern)
    - Test module setup: NestJS TestingModule with RmaModule
    - Shared fixtures created in beforeAll: one branch, five users (agent, manager, customer, finance, qc), actor contexts
    - Track all created RMA IDs in `const createdRmaIds: string[] = []`
    - afterAll: FK-safe cleanup (auditEvent → rmaLine → rma → userBranchRole → user → branch)
    - Each test describe block has a comment referencing its requirement ID (e.g., `// WKFL-02`)
    - Each test uses `expect(...).toBe()` / `expect(...).not.toBeNull()` — no snapshot tests

    **Run command to verify compile-clean:**
    ```bash
    cd rms-api && npx tsc --noEmit
    ```
    Expected: 0 errors. Tests are compile-clean even before Docker is available.

    **Run command to execute tests (requires Docker):**
    ```bash
    docker compose up -d && cd rms-api && npx prisma migrate deploy && npm run test:e2e -- --reporter=verbose workflow.integration
    ```
  </implementation>
</feature>

<verification>
1. `cd rms-api && npx tsc --noEmit` — 0 TypeScript errors (compile-clean check without running)
2. `cd rms-api && npm run build` — still 0 errors (no regressions)
3. `cd rms-api && npm test -- --testPathPatterns=rma.service.spec` — 41/41 Phase 2 unit tests still pass
4. `cd rms-api && grep -n "WKFL-01\|WKFL-02\|WKFL-03\|WKFL-04\|WKFL-05\|LINE-04" src/rma/workflow.integration.spec.ts` — all 6 requirement IDs present as comments in describe blocks
5. `cd rms-api && wc -l src/rma/workflow.integration.spec.ts` — at least 150 lines
</verification>

<success_criteria>
- workflow.integration.spec.ts exists and is TypeScript compile-clean (tsc --noEmit passes)
- All 6 requirement IDs appear as comments in describe blocks
- Test count: at minimum 15 tests (covering the behaviors listed above)
- afterAll cleanup is FK-safe and removes all test data
- Phase 2 unit tests still green (41/41)
- npm run build exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/03-workflow-and-line-operations/03-04-SUMMARY.md`
</output>
