---
phase: 03-workflow-and-line-operations
plan: 03
type: execute
wave: 3
depends_on:
  - 03-01
  - 03-02
files_modified:
  - rms-api/src/rma/rma.controller.ts
  - rms-api/src/rma/workflow.controller.ts
  - rms-api/src/rma/finance.controller.ts
  - rms-api/src/rma/rma.module.ts
autonomous: true
requirements:
  - WKFL-01
  - WKFL-02
  - WKFL-03
  - WKFL-04
  - WKFL-05
  - LINE-04

must_haves:
  truths:
    - "POST /rmas/:id/contest is accessible to CUSTOMER role and calls rmaService.contest()"
    - "POST /rmas/:id/overturn and /rmas/:id/uphold are accessible to BRANCH_MANAGER role"
    - "POST /rmas/:id/lines/:lineId/split is accessible to RETURNS_AGENT role"
    - "GET /approvals/queue returns SUBMITTED and CONTESTED RMAs for the requesting Branch Manager's branches"
    - "POST /approvals/:id/approve and /approvals/:id/reject route through rmaService.approve() and rmaService.reject()"
    - "GET /finance/credit-approvals returns unapproved CREDIT lines in QC_COMPLETE RMAs"
    - "POST /rmas/:id/lines/:lineId/approve-credit is accessible to FINANCE role"
    - "POST /rmas/:id/lines/:lineId/qc-inspection is accessible to QC role"
    - "All controllers use @UseGuards(RmsAuthGuard, RolesGuard) and @Inject() on constructor params"
    - "RmaModule declares all three controllers and exports RmaService"
    - "TypeScript build passes with zero errors"
  artifacts:
    - path: "rms-api/src/rma/rma.controller.ts"
      provides: "RMA lifecycle action endpoints: contest, overturn, uphold, splitLine, qcInspection, approveCredit"
    - path: "rms-api/src/rma/workflow.controller.ts"
      provides: "Branch Manager approval queue and contest flow endpoints"
    - path: "rms-api/src/rma/finance.controller.ts"
      provides: "Finance credit approval queue endpoint"
    - path: "rms-api/src/rma/rma.module.ts"
      provides: "NestJS module declaring all three controllers"
  key_links:
    - from: "rms-api/src/rma/rma.controller.ts"
      to: "rms-api/src/rma/rma.service.ts"
      via: "@Inject(RmaService) in controller constructor"
      pattern: "@Inject\\(RmaService\\)"
    - from: "rms-api/src/rma/workflow.controller.ts"
      to: "rms-api/src/rma/rma.repository.ts"
      via: "@Inject(RmaRepository) for queue query"
      pattern: "@Inject\\(RmaRepository\\)"
    - from: "rms-api/src/rma/rma.module.ts"
      to: "rms-api/src/rma/workflow.controller.ts"
      via: "controllers: [..., WorkflowController, FinanceController]"
      pattern: "WorkflowController"
---

<objective>
Create three NestJS controllers (rma.controller.ts, workflow.controller.ts, finance.controller.ts) and wire them into RmaModule. Each controller is thin: authenticate via guard chain, parse body with Zod, call service method, return result.

Purpose: This is the HTTP surface of Phase 3 — the layer that makes all Phase 2+3 service logic accessible via REST. No business logic lives in controllers.
Output: Three controller files, updated rma.module.ts, all Phase 3 requirements reachable via HTTP.
</objective>

<execution_context>
@C:/Users/megan.delia/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/megan.delia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-workflow-and-line-operations/03-CONTEXT.md
@.planning/phases/03-workflow-and-line-operations/03-RESEARCH.md

@.planning/phases/03-workflow-and-line-operations/03-01-SUMMARY.md
@.planning/phases/03-workflow-and-line-operations/03-02-SUMMARY.md
@.planning/phases/02-core-rma-lifecycle/02-03-SUMMARY.md

<interfaces>
<!-- Mandatory NestJS controller pattern from Phase 1 research -->

Two-step guard chain — EVERY controller class must have this decorator:
```typescript
@UseGuards(RmsAuthGuard, RolesGuard)
```

JwtAuthGuard is already the global APP_GUARD (wired in AppModule) — do NOT add it per-controller.
RmsAuthGuard populates `req.rmsUser: RmsUserContext`.
RolesGuard reads `@Roles('ROLE_NAME')` from handler metadata.

Controller constructor — @Inject() REQUIRED on every param (esbuild constraint):
```typescript
constructor(@Inject(RmaService) private readonly rmaService: RmaService) {}
```

Zod body validation pattern:
```typescript
@Post(':id/contest')
@Roles('CUSTOMER')
async contest(
  @Param('id') id: string,
  @Body() body: unknown,
  @Req() req: Request & { rmsUser: RmsUserContext },
) {
  const result = ContestInputSchema.safeParse(body);
  if (!result.success) throw new BadRequestException(result.error.flatten());
  return this.rmaService.contest(id, result.data, req.rmsUser);
}
```

RmsUserContext shape (from users.service.ts):
```typescript
interface RmsUserContext {
  id: string;
  email: string;
  role: string;        // e.g. 'BRANCH_MANAGER', 'CUSTOMER', 'FINANCE', 'QC', 'RETURNS_AGENT'
  branchIds: string[];
}
```

Role name strings — must match exactly as stored in user_branch_roles:
- 'RETURNS_AGENT'
- 'BRANCH_MANAGER'
- 'WAREHOUSE'
- 'QC'
- 'FINANCE'
- 'ADMIN'
- 'CUSTOMER'

RmaModule current shape (Phase 2):
```typescript
@Module({
  imports: [AuditModule],
  providers: [RmaService, RmaRepository],
  exports: [RmaService],
})
export class RmaModule {}
```
Phase 3 must add three controllers to `controllers: []`.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rma.controller.ts with lifecycle action endpoints</name>
  <files>
    rms-api/src/rma/rma.controller.ts
  </files>
  <action>
    Create rms-api/src/rma/rma.controller.ts (this file does NOT exist yet — create it from scratch).

    This controller handles RMA-level action endpoints: contest, overturn, uphold, line split, QC inspection recording, and credit line approval. It does NOT handle CRUD (list/get/create) — those can be added in a future plan. Phase 3 only needs the workflow action endpoints.

    ```typescript
    import {
      Controller, Post, Param, Body, Req, UseGuards, Inject,
      BadRequestException,
    } from '@nestjs/common';
    import { z } from 'zod';
    import { RmsAuthGuard } from '../auth/rms-auth.guard.js';
    import { RolesGuard } from '../auth/roles.guard.js';
    import { Roles } from '../auth/roles.decorator.js';
    import { RmaService } from './rma.service.js';
    import type { RmsUserContext } from '../users/users.service.js';

    // Zod schemas for request bodies
    const ContestBodySchema = z.object({
      disputeReason: z.string().min(1, 'Dispute reason is required'),
    });

    const ResolutionNoteBodySchema = z.object({
      resolutionNote: z.string().min(1, 'Resolution note is required'),
    });

    const SplitLineBodySchema = z.object({
      splits: z.array(z.object({
        partNumber: z.string().min(1),
        orderedQty: z.number().int().positive(),
        reasonCode: z.string().min(1),
        disposition: z.enum(['CREDIT', 'REPLACEMENT', 'SCRAP', 'RTV']).optional(),
      })).min(2, 'Split must produce at least 2 lines'),
    });

    const QcInspectionBodySchema = z.object({
      inspectedQty: z.number().int().min(0),
      qcPass: z.boolean().optional(),
      qcFindings: z.string().optional(),
      qcDispositionRecommendation: z.enum(['CREDIT', 'REPLACEMENT', 'SCRAP', 'RTV']).optional(),
    });

    @Controller('rmas')
    @UseGuards(RmsAuthGuard, RolesGuard)
    export class RmaController {
      constructor(@Inject(RmaService) private readonly rmaService: RmaService) {}

      // WKFL-02: Customer contests a REJECTED RMA
      @Post(':id/contest')
      @Roles('CUSTOMER')
      async contest(
        @Param('id') id: string,
        @Body() body: unknown,
        @Req() req: Request & { rmsUser: RmsUserContext },
      ) {
        const result = ContestBodySchema.safeParse(body);
        if (!result.success) throw new BadRequestException(result.error.flatten());
        return this.rmaService.contest(id, result.data, req.rmsUser);
      }

      // WKFL-03: Branch Manager overturns CONTESTED → APPROVED
      @Post(':id/overturn')
      @Roles('BRANCH_MANAGER')
      async overturn(
        @Param('id') id: string,
        @Body() body: unknown,
        @Req() req: Request & { rmsUser: RmsUserContext },
      ) {
        const result = ResolutionNoteBodySchema.safeParse(body);
        if (!result.success) throw new BadRequestException(result.error.flatten());
        return this.rmaService.overturn(id, result.data, req.rmsUser);
      }

      // WKFL-03: Branch Manager upholds CONTESTED → CLOSED
      @Post(':id/uphold')
      @Roles('BRANCH_MANAGER')
      async uphold(
        @Param('id') id: string,
        @Body() body: unknown,
        @Req() req: Request & { rmsUser: RmsUserContext },
      ) {
        const result = ResolutionNoteBodySchema.safeParse(body);
        if (!result.success) throw new BadRequestException(result.error.flatten());
        return this.rmaService.uphold(id, result.data, req.rmsUser);
      }

      // LINE-04: Returns Agent splits a line
      @Post(':id/lines/:lineId/split')
      @Roles('RETURNS_AGENT')
      async splitLine(
        @Param('id') id: string,
        @Param('lineId') lineId: string,
        @Body() body: unknown,
        @Req() req: Request & { rmsUser: RmsUserContext },
      ) {
        const result = SplitLineBodySchema.safeParse(body);
        if (!result.success) throw new BadRequestException(result.error.flatten());
        return this.rmaService.splitLine(id, lineId, result.data.splits, req.rmsUser);
      }

      // WKFL-05: QC staff records per-line inspection results
      @Post(':id/lines/:lineId/qc-inspection')
      @Roles('QC')
      async recordQcInspection(
        @Param('id') id: string,
        @Param('lineId') lineId: string,
        @Body() body: unknown,
        @Req() req: Request & { rmsUser: RmsUserContext },
      ) {
        const result = QcInspectionBodySchema.safeParse(body);
        if (!result.success) throw new BadRequestException(result.error.flatten());
        return this.rmaService.recordQcInspection(id, {
          lineId,
          inspectedQty: result.data.inspectedQty,
          qcPass: result.data.qcPass,
          qcFindings: result.data.qcFindings,
          qcDispositionRecommendation: result.data.qcDispositionRecommendation as any,
        }, req.rmsUser);
      }

      // WKFL-04: Finance approves a CREDIT line
      @Post(':id/lines/:lineId/approve-credit')
      @Roles('FINANCE')
      async approveLineCredit(
        @Param('id') id: string,
        @Param('lineId') lineId: string,
        @Req() req: Request & { rmsUser: RmsUserContext },
      ) {
        return this.rmaService.approveLineCredit(id, lineId, req.rmsUser);
      }
    }
    ```
  </action>
  <verify>
    Run: `cd rms-api && npm run build`
    Expected: exits 0, "Found 0 errors."

    Run: `cd rms-api && grep -n "@Post\|@Roles\|@Inject" src/rma/rma.controller.ts`
    Expected: 6 @Post decorators (contest, overturn, uphold, split, qc-inspection, approve-credit), matching @Roles decorators, @Inject in constructor.
  </verify>
  <done>rma.controller.ts created with 6 action endpoints, @UseGuards on class, @Roles per method, @Inject in constructor, Zod validation on all body-accepting methods. npm run build exits 0.</done>
</task>

<task type="auto">
  <name>Task 2: Create workflow.controller.ts and finance.controller.ts, update rma.module.ts</name>
  <files>
    rms-api/src/rma/workflow.controller.ts
    rms-api/src/rma/finance.controller.ts
    rms-api/src/rma/rma.module.ts
  </files>
  <action>
    **Create rms-api/src/rma/workflow.controller.ts (new file):**

    This controller handles the Branch Manager approval queue (WKFL-01) and approval/rejection from that queue. It also re-exposes the approve/reject actions through a workflow-focused path for queue-driven use.

    ```typescript
    import {
      Controller, Get, Post, Param, Body, Query, Req, UseGuards, Inject,
      BadRequestException,
    } from '@nestjs/common';
    import { z } from 'zod';
    import { RmsAuthGuard } from '../auth/rms-auth.guard.js';
    import { RolesGuard } from '../auth/roles.guard.js';
    import { Roles } from '../auth/roles.decorator.js';
    import { RmaService } from './rma.service.js';
    import { RmaRepository } from './rma.repository.js';
    import type { RmsUserContext } from '../users/users.service.js';

    const ApproveBodySchema = z.object({ /* no body needed */ }).optional();
    const RejectBodySchema = z.object({
      rejectionReason: z.string().min(1, 'Rejection reason is required'),
    });

    @Controller('approvals')
    @UseGuards(RmsAuthGuard, RolesGuard)
    @Roles('BRANCH_MANAGER')
    export class WorkflowController {
      constructor(
        @Inject(RmaService) private readonly rmaService: RmaService,
        @Inject(RmaRepository) private readonly rmaRepository: RmaRepository,
      ) {}

      // WKFL-01: Branch Manager views approvals queue (SUBMITTED + CONTESTED RMAs)
      // GET /approvals/queue?branchId=xxx&status=SUBMITTED&take=50&skip=0
      @Get('queue')
      async getApprovalQueue(
        @Query('branchId') branchId: string | undefined,
        @Query('status') status: string | undefined,
        @Query('take') take: string | undefined,
        @Query('skip') skip: string | undefined,
        @Req() req: Request & { rmsUser: RmsUserContext },
      ) {
        return this.rmaRepository.findForApprovalQueue(req.rmsUser, {
          branchId,
          status: status as any,   // RmaStatus — validated inside repository
          take: take ? parseInt(take, 10) : undefined,
          skip: skip ? parseInt(skip, 10) : undefined,
        });
      }

      // WKFL-01: Branch Manager approves from queue
      @Post(':id/approve')
      async approve(
        @Param('id') id: string,
        @Req() req: Request & { rmsUser: RmsUserContext },
      ) {
        return this.rmaService.approve(id, req.rmsUser);
      }

      // WKFL-01: Branch Manager rejects from queue
      @Post(':id/reject')
      async reject(
        @Param('id') id: string,
        @Body() body: unknown,
        @Req() req: Request & { rmsUser: RmsUserContext },
      ) {
        const result = RejectBodySchema.safeParse(body);
        if (!result.success) throw new BadRequestException(result.error.flatten());
        return this.rmaService.reject(id, result.data, req.rmsUser);
      }
    }
    ```

    **Create rms-api/src/rma/finance.controller.ts (new file):**

    ```typescript
    import {
      Controller, Get, Query, Req, UseGuards, Inject,
    } from '@nestjs/common';
    import { RmsAuthGuard } from '../auth/rms-auth.guard.js';
    import { RolesGuard } from '../auth/roles.guard.js';
    import { Roles } from '../auth/roles.decorator.js';
    import { RmaRepository } from './rma.repository.js';
    import type { RmsUserContext } from '../users/users.service.js';

    @Controller('finance')
    @UseGuards(RmsAuthGuard, RolesGuard)
    @Roles('FINANCE')
    export class FinanceController {
      constructor(
        @Inject(RmaRepository) private readonly rmaRepository: RmaRepository,
      ) {}

      // WKFL-04: Finance views credit lines awaiting approval
      // GET /finance/credit-approvals?take=100&skip=0
      @Get('credit-approvals')
      async getCreditApprovals(
        @Query('take') take: string | undefined,
        @Query('skip') skip: string | undefined,
        @Req() req: Request & { rmsUser: RmsUserContext },
      ) {
        return this.rmaRepository.findCreditApprovalLines(req.rmsUser, {
          take: take ? parseInt(take, 10) : undefined,
          skip: skip ? parseInt(skip, 10) : undefined,
        });
      }
    }
    ```

    **Update rms-api/src/rma/rma.module.ts:**

    Read the existing rma.module.ts and add the three controllers:

    ```typescript
    import { Module } from '@nestjs/common';
    import { AuditModule } from '../audit/audit.module.js';
    import { RmaService } from './rma.service.js';
    import { RmaRepository } from './rma.repository.js';
    import { RmaController } from './rma.controller.js';
    import { WorkflowController } from './workflow.controller.js';
    import { FinanceController } from './finance.controller.js';

    @Module({
      imports: [AuditModule],
      controllers: [RmaController, WorkflowController, FinanceController],
      providers: [RmaService, RmaRepository],
      exports: [RmaService],
    })
    export class RmaModule {}
    ```

    NOTE: WorkflowController injects both RmaService and RmaRepository — both are in `providers`, so NestJS DI resolves them. FinanceController only injects RmaRepository. No additional providers are needed.
  </action>
  <verify>
    Run: `cd rms-api && npm run build`
    Expected: exits 0, "Found 0 errors."

    Run: `cd rms-api && grep -n "WorkflowController\|FinanceController\|RmaController" src/rma/rma.module.ts`
    Expected: All three controllers imported and listed in controllers array.

    Run: `cd rms-api && grep -n "@Get\|@Post\|@Roles\|@Inject" src/rma/workflow.controller.ts src/rma/finance.controller.ts`
    Expected: @Get('queue') in workflow, @Post(':id/approve') and @Post(':id/reject') in workflow, @Get('credit-approvals') in finance, @Inject in both constructors.
  </verify>
  <done>workflow.controller.ts and finance.controller.ts created. rma.module.ts has controllers: [RmaController, WorkflowController, FinanceController]. npm run build exits 0.</done>
</task>

</tasks>

<verification>
1. `cd rms-api && npm run build` — 0 TypeScript errors
2. `cd rms-api && npm test -- --testPathPatterns=rma.service.spec` — 41/41 pass (no regression)
3. `cd rms-api && grep "RmaController\|WorkflowController\|FinanceController" src/rma/rma.module.ts` — all 3 in controllers array
4. `cd rms-api && ls src/rma/*.controller.ts` — rma.controller.ts, workflow.controller.ts, finance.controller.ts all exist
5. All controllers have @UseGuards(RmsAuthGuard, RolesGuard) on the class
</verification>

<success_criteria>
- rma.controller.ts: 6 action endpoints (contest/overturn/uphold/split/qc-inspection/approve-credit)
- workflow.controller.ts: GET /approvals/queue + POST /approvals/:id/approve + POST /approvals/:id/reject
- finance.controller.ts: GET /finance/credit-approvals
- rma.module.ts: controllers array contains all three
- Every controller class has @UseGuards(RmsAuthGuard, RolesGuard)
- Every constructor uses @Inject(Token) on all params
- npm run build exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/03-workflow-and-line-operations/03-03-SUMMARY.md`
</output>
