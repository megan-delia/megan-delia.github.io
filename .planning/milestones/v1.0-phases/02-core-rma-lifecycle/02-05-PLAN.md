---
phase: 02-core-rma-lifecycle
plan: 05
type: tdd
wave: 5
depends_on:
  - "02-04-PLAN"
files_modified:
  - rms-api/src/rma/rma.service.spec.ts
  - rms-api/src/rma/rma.service.integration.spec.ts
autonomous: true
requirements:
  - LCYC-01
  - LCYC-02
  - LCYC-03
  - LCYC-04
  - LCYC-05
  - LCYC-06
  - LCYC-07
  - LCYC-08
  - LCYC-09
  - LCYC-10
  - LCYC-11
  - LINE-01
  - LINE-02
  - LINE-03

must_haves:
  truths:
    - "Jest unit tests for assertValidTransition() cover every valid transition and every invalid (must-throw) transition — all pass without DB or DI"
    - "Jest unit tests for business guard logic (empty reason, empty lines, qty bounds) pass"
    - "Vitest integration tests create a real DRAFT RMA with lines and confirm the audit event row exists in the DB"
    - "Vitest integration tests confirm that an invalid transition throws BadRequestException before touching the DB (no state change written)"
    - "Vitest integration tests confirm first-receipt logic: APPROVED → RECEIVED on the first recordReceipt(); status does not change on subsequent calls"
    - "Vitest integration tests confirm inspectedQty > receivedQty is rejected"
    - "All unit tests (npm test -- rma) pass with no DB or Docker required"
    - "All integration tests (npm run test:e2e) pass when Docker and migrations are available"
  artifacts:
    - path: "rms-api/src/rma/rma.service.spec.ts"
      provides: "Jest unit tests for assertValidTransition() and guard logic — no DB required"
      exports: []
    - path: "rms-api/src/rma/rma.service.integration.spec.ts"
      provides: "Vitest integration tests for all 14 LCYC/LINE requirements against real Postgres DB"
      exports: []
  key_links:
    - from: "rms-api/src/rma/rma.service.spec.ts"
      to: "rms-api/src/rma/rma-lifecycle.ts"
      via: "Direct import of assertValidTransition() — pure function, no mocking needed"
      pattern: "import.*rma-lifecycle"
    - from: "rms-api/src/rma/rma.service.integration.spec.ts"
      to: "rms-api/src/rma/rma.module.ts"
      via: "NestJS TestingModule imports RmaModule; gets RmaService via moduleRef.get(RmaService)"
      pattern: "RmaModule"
---

<objective>
Create the test suite for Phase 2: pure Jest unit tests for the state machine and guard logic (no DB required), and Vitest integration tests that exercise the full RmaService against a real Postgres database.

Purpose: The RED→GREEN cycle is already satisfied (service is written). These tests prove correctness of the complete implementation and establish the regression baseline for Phase 3. The dual-runner setup (Jest unit + Vitest integration) follows the same pattern established in Phase 1.

Output: rma.service.spec.ts (Jest, runs anywhere) and rma.service.integration.spec.ts (Vitest, requires Docker + DB).
</objective>

<execution_context>
@C:/Users/megan.delia/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/megan.delia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-core-rma-lifecycle/02-RESEARCH.md
@.planning/phases/02-core-rma-lifecycle/02-04-SUMMARY.md
@.planning/phases/01-foundation/01-04-SUMMARY.md

<interfaces>
<!-- Testing infrastructure from Phase 1 — use exactly these patterns -->

Jest unit test runner (rms-api/package.json jest config):
```json
// testRegex: src/**/*.spec.ts (excluding .e2e.spec.ts, .integration.spec.ts, merp-stub.spec.ts)
// moduleNameMapper: "^(\\.\\.\\.?/.*)\\.js$": "$1"  (strips .js for ts-jest resolution)
// Run: cd rms-api && npm test -- --testPathPattern=rma
```

Vitest integration test runner (rms-api/vitest.integration.config.ts):
```typescript
// include: src/**/*.integration.spec.ts, src/**/*.e2e.spec.ts, src/**/merp-stub.spec.ts
// setupFiles: ['reflect-metadata', 'dotenv/config']
// sequence: { concurrent: false }  — tests run sequentially (shared DB)
// pool: 'forks', singleFork: true
// Run: cd rms-api && npm run test:e2e
// Requires: Docker running, DATABASE_URL in .env, npx prisma migrate deploy
```

Unit test import pattern (Phase 1 branch-scope.spec.ts):
```typescript
// Import from enums (not client) to avoid Prisma 7 import.meta in CJS Jest
import { RmaStatus } from '../../generated/prisma/enums.js';
// Mock PrismaService if the module imports from prisma (even indirectly)
jest.mock('../prisma/prisma.service.js');
```

Vitest integration test pattern (Phase 1 audit.integration.spec.ts):
```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { ConfigModule } from '@nestjs/config';
import { PrismaModule } from '../prisma/prisma.module.js';
import { AuditModule } from '../audit/audit.module.js';

describe('...', () => {
  let moduleRef: TestingModule;
  let rmaService: RmaService;
  let prisma: PrismaService;

  beforeAll(async () => {
    moduleRef = await Test.createTestingModule({
      imports: [
        ConfigModule.forRoot({ isGlobal: true }),
        PrismaModule,
        AuditModule,
        RmaModule,
      ],
    }).compile();
    rmaService = moduleRef.get(RmaService);
    prisma = moduleRef.get(PrismaService);
  });

  afterAll(async () => {
    // Cleanup in FK-safe reverse order: audit events → rma lines → rmas → users → branches
    await moduleRef.close();
  });
});
```

Seeding pattern for integration tests — each test that needs DB data must create seed records:
```typescript
// Seed a Branch and User before creating an RMA
const branch = await prisma.branch.create({ data: { name: 'Test Branch', code: 'TEST-B1' } });
const user = await prisma.user.create({
  data: {
    portalUserId: `test-portal-${Date.now()}`,
    email: `test-${Date.now()}@test.com`,
    displayName: 'Test Agent',
    branchRoles: { create: [{ branchId: branch.id, role: RmsRole.RETURNS_AGENT, assignedBy: 'system' }] },
  },
});
const actor: RmaActorContext = {
  id: user.id, portalUserId: user.portalUserId, email: user.email,
  role: RmsRole.RETURNS_AGENT, branchIds: [branch.id], isAdmin: false,
};
```
</interfaces>
</context>

<feature>
  <name>RMA Lifecycle State Machine and Service — Full Test Suite</name>
  <files>rms-api/src/rma/rma.service.spec.ts, rms-api/src/rma/rma.service.integration.spec.ts</files>
  <behavior>
    **Unit test behaviors (Jest, rma.service.spec.ts):**

    assertValidTransition():
    - DRAFT → SUBMITTED: does not throw
    - DRAFT → CANCELLED: does not throw
    - SUBMITTED → APPROVED: does not throw
    - SUBMITTED → REJECTED: does not throw
    - SUBMITTED → INFO_REQUIRED: does not throw
    - SUBMITTED → CANCELLED: does not throw
    - INFO_REQUIRED → SUBMITTED: does not throw
    - INFO_REQUIRED → CANCELLED: does not throw
    - APPROVED → RECEIVED: does not throw
    - APPROVED → CANCELLED: does not throw
    - RECEIVED → QC_COMPLETE: does not throw
    - QC_COMPLETE → RESOLVED: does not throw
    - RESOLVED → CLOSED: does not throw
    - DRAFT → APPROVED: throws BadRequestException
    - SUBMITTED → RECEIVED: throws BadRequestException (must go through APPROVED)
    - CANCELLED → DRAFT: throws BadRequestException (terminal state)
    - REJECTED → SUBMITTED: throws BadRequestException (terminal state)
    - CLOSED → RESOLVED: throws BadRequestException (terminal state)
    - Error body contains allowedTransitions array

    **Integration test behaviors (Vitest, rma.service.integration.spec.ts):**

    LCYC-01 + LINE-01: createDraft()
    - Creates RMA with DRAFT status
    - Creates all provided line items with correct fields
    - Writes AuditEvent with action RMA_CREATED in same transaction
    - Returns RmaWithLines including lines array

    LCYC-02: submit()
    - Transitions DRAFT → SUBMITTED
    - Writes AuditEvent with action RMA_SUBMITTED
    - Throws BadRequestException when called on a SUBMITTED RMA (invalid transition)

    LCYC-03: approve()
    - Transitions SUBMITTED → APPROVED
    - Writes AuditEvent with action RMA_APPROVED

    LCYC-04: reject()
    - Transitions SUBMITTED → REJECTED with rejectionReason stored
    - Throws BadRequestException when rejectionReason is empty string

    LCYC-05: placeInfoRequired()
    - Transitions SUBMITTED → INFO_REQUIRED
    - Writes AuditEvent with action RMA_INFO_REQUIRED

    LCYC-06: resubmit()
    - Transitions INFO_REQUIRED → SUBMITTED
    - Writes AuditEvent with action RMA_SUBMITTED and metadata.cycle = 'resubmit'

    LCYC-11: cancel()
    - Transitions DRAFT → CANCELLED with cancellationReason stored
    - Throws BadRequestException when cancellationReason is empty
    - Throws BadRequestException when attempting to cancel a CANCELLED RMA (invalid transition)

    LCYC-07 + LINE-03: recordReceipt()
    - First call: transitions APPROVED → RECEIVED, updates line.receivedQty
    - Second call: stays RECEIVED, updates line.receivedQty (no duplicate transition)
    - receivedQty exceeds orderedQty: succeeds (over-receipt allowed)
    - receivedQty below existing inspectedQty: throws BadRequestException

    LCYC-08 + LINE-03: recordQcInspection()
    - Sets inspectedQty and qcInspectedAt on the line
    - inspectedQty > receivedQty: throws BadRequestException
    - inspectedQty = 0: succeeds

    LCYC-08 completion: completeQc()
    - Transitions RECEIVED → QC_COMPLETE

    LCYC-09: resolve()
    - Transitions QC_COMPLETE → RESOLVED

    LCYC-10: close()
    - Transitions RESOLVED → CLOSED

    LINE-02: disposition lock
    - updateLine() succeeds when qcInspectedAt is null on the line
    - updateLine() throws BadRequestException when qcInspectedAt is set on the line
  </behavior>
  <implementation>
    Create rma.service.spec.ts as a pure Jest unit test file. Import assertValidTransition from rma-lifecycle.ts directly. Use jest.mock() for any modules that import PrismaClient (Prisma 7 ESM constraint from Phase 1). No TestingModule needed — assertValidTransition is a plain function.

    Create rma.service.integration.spec.ts as a Vitest integration test file. Use the TestingModule pattern from Phase 1 audit.integration.spec.ts. Seed Branch and User rows before tests. Clean up all created rows in afterAll in FK-safe reverse order (auditEvent → rmaLine → rma → userBranchRole → user → branch). Use unique timestamps or UUIDs in seeded data to prevent collisions between test runs.

    CRITICAL: Unit tests import from enums.js (not client.js) to avoid Prisma 7 import.meta in CJS Jest.
    CRITICAL: Integration tests use Vitest (ESM-native) and import from client.js — the full Prisma client works correctly in Vitest.
    CRITICAL: All integration tests run sequentially (vitest.integration.config.ts already sets concurrent: false).
    CRITICAL: The first-receipt test must verify: (1) status is RECEIVED after first call, (2) status is still RECEIVED (not a second transition) after second call, (3) two distinct audit entries exist.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: Write Jest unit tests for state machine and guard logic</name>
  <files>rms-api/src/rma/rma.service.spec.ts</files>
  <action>
    Create rms-api/src/rma/rma.service.spec.ts covering all valid/invalid transitions and the pure guard logic checks. This file uses Jest (not Vitest) and requires no DB connection.

    Import pattern for unit tests (avoids Prisma 7 import.meta issue in CJS Jest):
    ```typescript
    // Import from enums only — never from client.js in Jest unit tests
    import { RmaStatus } from '../../generated/prisma/enums.js';
    import { assertValidTransition } from './rma-lifecycle.js';
    import { BadRequestException } from '@nestjs/common';
    ```

    The test file should cover:
    1. Valid transitions: all 13 valid (from, to) pairs in ALLOWED_TRANSITIONS — each with `expect(() => assertValidTransition(X, Y)).not.toThrow()`
    2. Invalid transitions: at least 6 representative invalid pairs — each with `expect(() => assertValidTransition(X, Y)).toThrow(BadRequestException)`
    3. Terminal states: REJECTED, CANCELLED, CLOSED each throw on any outgoing transition attempt
    4. Error body: one test confirming the thrown BadRequestException contains `{ error: 'INVALID_TRANSITION', allowedTransitions: [...] }`
    5. Guard logic tests (pure, no DB):
       - Empty cancellationReason string → service should throw (test the guard condition: `''.trim().length === 0`)
       - Empty rejectionReason string → same check
       - inspectedQty > receivedQty → the comparison that triggers the guard
       - receivedQty < inspectedQty → the comparison for the receipt lower-bound guard

    For guard logic tests (5), since they test comparisons not service methods, write them as plain describe/it blocks testing the boolean expressions directly — no DI or mocking needed.

    Run after writing:
    ```bash
    cd rms-api && npm test -- --testPathPattern=rma 2>&1 | tail -20
    ```
    All tests must pass (GREEN).
  </action>
  <verify>
    <automated>cd "C:/Users/megan.delia/OneDrive - Master Electronics/Desktop/Claude Workshop/rms-api" && npm test -- --testPathPattern=rma.service.spec 2>&1 | grep -E "Tests:|passed|failed" | tail -5</automated>
  </verify>
  <done>rma.service.spec.ts exists with at least 22 tests covering all 13 valid transitions, 6+ invalid transitions, terminal state tests, error body shape test, and guard logic conditions. All tests pass GREEN with npm test -- --testPathPattern=rma.service.spec. No DB or Docker required to run.</done>
</task>

<task type="auto">
  <name>Task 2: Write Vitest integration tests for all LCYC and LINE requirements</name>
  <files>rms-api/src/rma/rma.service.integration.spec.ts</files>
  <action>
    Create rms-api/src/rma/rma.service.integration.spec.ts following the Phase 1 audit.integration.spec.ts pattern. This file requires Docker + DATABASE_URL + applied migrations to run.

    Structure:
    ```
    describe('RmaService Integration', () => {
      // beforeAll: bootstrap TestingModule with [ConfigModule, PrismaModule, AuditModule, RmaModule]
      // Seed one Branch + one User (RETURNS_AGENT) reused across all tests

      describe('LCYC-01 + LINE-01: createDraft()', () => {
        // 2 tests: creates RMA in DRAFT with lines; audit event written in same tx
      })

      describe('LCYC-02: submit()', () => {
        // 2 tests: transitions to SUBMITTED; invalid transition throws
      })

      describe('LCYC-03: approve()', () => {
        // 1 test: SUBMITTED → APPROVED
      })

      describe('LCYC-04: reject()', () => {
        // 2 tests: SUBMITTED → REJECTED with reason; empty reason throws
      })

      describe('LCYC-05: placeInfoRequired()', () => {
        // 1 test: SUBMITTED → INFO_REQUIRED
      })

      describe('LCYC-06: resubmit()', () => {
        // 1 test: INFO_REQUIRED → SUBMITTED
      })

      describe('LCYC-11: cancel()', () => {
        // 3 tests: DRAFT → CANCELLED; empty reason throws; CANCELLED → anything throws
      })

      describe('LCYC-07 + LINE-03: recordReceipt()', () => {
        // 3 tests: first receipt → RECEIVED; second receipt → stays RECEIVED; over-receipt OK
      })

      describe('LCYC-08 + LINE-03: recordQcInspection()', () => {
        // 2 tests: sets inspectedQty + qcInspectedAt; inspectedQty > receivedQty throws
      })

      describe('LCYC-08 completion: completeQc()', () => {
        // 1 test: RECEIVED → QC_COMPLETE
      })

      describe('LCYC-09: resolve()', () => {
        // 1 test: QC_COMPLETE → RESOLVED
      })

      describe('LCYC-10: close()', () => {
        // 1 test: RESOLVED → CLOSED
      })

      describe('LINE-02: disposition lock', () => {
        // 2 tests: disposition updatable before QC; locked after qcInspectedAt set
      })

      // afterAll: cleanup in FK-safe order
      //   prisma.auditEvent.deleteMany({ where: { rmaId: { in: createdRmaIds } } })
      //   prisma.rmaLine.deleteMany({ where: { rmaId: { in: createdRmaIds } } })
      //   prisma.rma.deleteMany({ where: { id: { in: createdRmaIds } } })
      //   prisma.userBranchRole.deleteMany({ where: { userId: seedUser.id } })
      //   prisma.user.delete({ where: { id: seedUser.id } })
      //   prisma.branch.delete({ where: { id: seedBranch.id } })
    })
    ```

    Important implementation notes:
    - Track all created RMA IDs in a `createdRmaIds: string[]` array for cleanup
    - Each test that needs a fresh RMA creates it via rmaService.createDraft() — do not reuse RMAs across tests that transition them (state changes are irreversible for terminal states)
    - For the full lifecycle test (LCYC-07 through LCYC-10), chain the operations: createDraft → submit → approve → recordReceipt → recordQcInspection → completeQc → resolve → close
    - Use `import { RmaStatus, RmsRole } from '../../generated/prisma/client.js'` in Vitest (full client works — ESM native)
    - Use `import { RmaStatus, RmsRole } from '../../generated/prisma/enums.js'` only in Jest unit tests

    For the first-receipt test, assert:
    1. After createDraft + submit + approve: rma.status === 'APPROVED'
    2. After recordReceipt(line1): rma.status === 'RECEIVED'
    3. After recordReceipt(line1) again: rma.status === 'RECEIVED' (not double-transitioned)
    4. Count AuditEvents with action RMA_RECEIVED === 1 (not 2)

    Do NOT run npm run test:e2e at the end — integration tests require Docker which may not be available. The verify command checks that the file compiles.
  </action>
  <verify>
    <automated>cd "C:/Users/megan.delia/OneDrive - Master Electronics/Desktop/Claude Workshop/rms-api" && npx tsc --noEmit 2>&1 | grep -c "rma.service.integration" | xargs -I{} test {} -eq 0 && echo "INTEGRATION_TYPES_OK"</automated>
  </verify>
  <done>rma.service.integration.spec.ts exists with at least 22 integration tests covering all 14 LCYC/LINE requirements. File compiles without TypeScript errors. Tests use the correct Vitest NestJS TestingModule pattern. afterAll cleanup deletes all created rows in FK-safe order. The file is ready to run with `npm run test:e2e` when Docker is available.</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Unit tests pass: `cd rms-api && npm test -- --testPathPattern=rma.service.spec 2>&1 | grep "passed"` — must show all tests passed
2. Unit test count: `grep -c "it(" rms-api/src/rma/rma.service.spec.ts` — must be 22+
3. Integration file compiles: `cd rms-api && npx tsc --noEmit 2>&1 | grep rma.service.integration` — no output = no errors
4. Integration test structure: `grep -c "it(" rms-api/src/rma/rma.service.integration.spec.ts` — must be 22+
5. Cleanup in afterAll: `grep -n "deleteMany\|delete" rms-api/src/rma/rma.service.integration.spec.ts` — must show multiple cleanup calls
6. First-receipt assertion: `grep -n "isFirstReceipt\|RMA_RECEIVED.*1\|auditEvent.*count" rms-api/src/rma/rma.service.integration.spec.ts` — must show the count assertion
7. No import from client.js in unit tests: `grep -n "from.*client.js" rms-api/src/rma/rma.service.spec.ts` — must return 0 matches
</verification>

<success_criteria>
- rma.service.spec.ts: All tests pass GREEN with `npm test -- --testPathPattern=rma.service.spec` — no Docker required
- rma.service.spec.ts: Covers all 13 valid transitions and at least 6 invalid transitions
- rma.service.spec.ts: Imports from enums.js (not client.js) to work in CJS Jest
- rma.service.integration.spec.ts: Compiles without TypeScript errors
- rma.service.integration.spec.ts: Tests all 14 LCYC/LINE requirements against real DB
- rma.service.integration.spec.ts: afterAll cleanup is FK-safe (audit → lines → rmas → users → branches)
- rma.service.integration.spec.ts: First-receipt test asserts exactly one RMA_RECEIVED audit event on double-receipt
- rma.service.integration.spec.ts: Ready to run with `npm run test:e2e` when Docker is available
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-rma-lifecycle/02-05-SUMMARY.md` with:
- Unit test results: N/N passing, list of test groups
- Integration test file status: compiled, N tests written, ready for Docker
- List of requirements covered per test group
- Import pattern used for unit vs. integration tests (enums.js vs. client.js)
- Instructions for running: npm test vs. npm run test:e2e
- Any deviations from plan (auto-fixed issues)
</output>
