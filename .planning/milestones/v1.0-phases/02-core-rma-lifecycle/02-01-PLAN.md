---
phase: 02-core-rma-lifecycle
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rms-api/prisma/schema.prisma
  - rms-api/src/rma/rma.types.ts
autonomous: true
requirements:
  - LCYC-01
  - LCYC-02
  - LCYC-03
  - LCYC-04
  - LCYC-05
  - LCYC-06
  - LCYC-07
  - LCYC-08
  - LCYC-09
  - LCYC-10
  - LCYC-11
  - LINE-01
  - LINE-02
  - LINE-03

must_haves:
  truths:
    - "The Prisma schema validates successfully — `npx prisma validate` exits 0 with no errors"
    - "The RmaStatus enum contains all 10 states: DRAFT, SUBMITTED, INFO_REQUIRED, APPROVED, RECEIVED, QC_COMPLETE, RESOLVED, CLOSED, REJECTED, CANCELLED"
    - "The DispositionType enum contains all 4 values: CREDIT, REPLACEMENT, SCRAP, RTV"
    - "The Rma model has rmaNumber (unique), status, branchId, customerId, submittedById, cancellationReason, rejectionReason, plus timestamps and relation to RmaLine and AuditEvent"
    - "The RmaLine model has partNumber, orderedQty (Int), reasonCode, disposition (nullable DispositionType), receivedQty (Int @default(0)), inspectedQty (Int @default(0)), qcInspectedAt (DateTime?)"
    - "The rma.types.ts file exports typed input shapes for all service method calls — no service method takes untyped parameters"
    - "TypeScript build passes with zero errors after schema and types are added"
  artifacts:
    - path: "rms-api/prisma/schema.prisma"
      provides: "Rma and RmaLine models, RmaStatus and DispositionType enums, back-reference relation on AuditEvent"
      contains: "model Rma"
    - path: "rms-api/src/rma/rma.types.ts"
      provides: "CreateRmaInput, LineInput, UpdateLineInput, RecordReceiptInput, RecordQcInput service input types"
      exports: ["CreateRmaInput", "LineInput", "UpdateLineInput", "RecordReceiptInput", "RecordQcInput", "RmaUserContext"]
  key_links:
    - from: "rms-api/prisma/schema.prisma"
      to: "rms-api/generated/prisma/client.js"
      via: "npx prisma generate produces typed Rma/RmaLine/RmaStatus/DispositionType exports"
      pattern: "model Rma"
    - from: "rms-api/src/rma/rma.types.ts"
      to: "rms-api/src/rma/rma.service.ts"
      via: "All service methods accept typed input from rma.types.ts — no unknown/any parameters"
      pattern: "import.*rma.types"
---

<objective>
Extend the Prisma schema with the Rma and RmaLine models (plus the RmaStatus and DispositionType enums), then create the typed input contract file that all downstream service methods will accept.

Purpose: Every plan in Phase 2 depends on the generated Prisma types. This plan runs first (Wave 1), unblocking all parallel Wave 2 plans. The types file establishes the contracts that make all service method signatures explicit — no service method accepts untyped parameters.

Output: An extended schema.prisma (validates with npx prisma validate), a generated Prisma client with Rma/RmaLine types, and a rma.types.ts file with all service input shapes.
</objective>

<execution_context>
@C:/Users/megan.delia/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/megan.delia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/02-core-rma-lifecycle/02-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

<interfaces>
<!-- Key Phase 1 contracts the executor needs — no codebase exploration required -->

From rms-api/prisma/schema.prisma (existing models — add Rma/RmaLine after these):
```prisma
// Existing User model has:
//   id String @id
//   portalUserId String @unique
//   auditEvents AuditEvent[] @relation("ActorAuditEvents")
//   branchRoles UserBranchRole[]
// NOTE: The Rma model must add a relation back to User for "submittedBy"
// Use relation name "SubmittedRmas" to avoid collision with auditEvents relation

// Existing Branch model has:
//   id String @id
// NOTE: The Rma model must add a relation to Branch

// Existing AuditEvent model has:
//   rmaId      String?   -- FK -> Rma (nullable, add @relation("RmaAuditEvents") back-reference)
//   rmaLineId  String?   -- FK -> RmaLine (nullable, no back-reference model yet)
// NOTE: AuditEvent already has rmaId field; add the relation field to connect it
```

From rms-api/src/audit/audit.types.ts:
```typescript
// AuditAction const object already includes all Phase 2 actions:
// RMA_CREATED, RMA_SUBMITTED, RMA_APPROVED, RMA_REJECTED, RMA_INFO_REQUIRED,
// RMA_CANCELLED, RMA_RECEIVED, RMA_RESOLVED, RMA_CLOSED
// LINE_ADDED, LINE_UPDATED, DISPOSITION_SET
// No new AuditAction values need to be added in Phase 2
export const AuditAction = { ... } as const;
export interface AuditEventInput {
  rmaId?: string; rmaLineId?: string; actorId: string; actorRole: string;
  action: AuditAction; fromStatus?: string; toStatus?: string;
  oldValue?: Record<string, unknown>; newValue?: Record<string, unknown>;
  metadata?: Record<string, unknown>; ipAddress?: string;
}
```

From rms-api/src/users/users.service.ts:
```typescript
// RmsUserContext — used as the actor parameter on all lifecycle methods
export interface RmsUserContext {
  id: string;           // RMS User.id (UUID)
  portalUserId: string;
  email: string;
  role: RmsRole;        // highest-priority role
  branchIds: string[];  // all branch assignments
  isAdmin: boolean;
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Prisma schema with Rma and RmaLine models</name>
  <files>rms-api/prisma/schema.prisma</files>
  <action>
    Append the RmaStatus enum, DispositionType enum, Rma model, and RmaLine model to the existing schema.prisma. Also add the missing @relation field on AuditEvent so Prisma can resolve the rmaId back-reference.

    LOCKED DECISIONS (from CONTEXT.md):
    - RMA transitions to Received immediately on first receipt entry (tracked via receivedQty per line, not a boolean flag)
    - Over-receipt is allowed — no max check on receivedQty
    - QC-inspected quantity is capped at received quantity per line (service enforces; no DB constraint needed for v1)
    - Disposition is optional at submission (nullable)
    - Disposition is locked per-line after qcInspectedAt IS NOT NULL (use qcInspectedAt DateTime? as the trigger)
    - Lines are fully editable in DRAFT and INFO_REQUIRED; locked from SUBMITTED onward
    - Info Required is cancellable (LCYC-11 covers DRAFT, SUBMITTED, APPROVED, INFO_REQUIRED)
    - RMA number format: use `RMA-YYYYMM-NNNNNN` sequential format (per RESEARCH.md open question resolution)

    Add to schema.prisma after the existing models (after MerpIntegrationLog). Do NOT modify any existing models except AuditEvent (add the rma relation field).

    Enums to add:
    ```prisma
    enum RmaStatus {
      DRAFT
      SUBMITTED
      INFO_REQUIRED
      APPROVED
      RECEIVED
      QC_COMPLETE
      RESOLVED
      CLOSED
      REJECTED
      CANCELLED
    }

    enum DispositionType {
      CREDIT
      REPLACEMENT
      SCRAP
      RTV
    }
    ```

    Rma model:
    ```prisma
    model Rma {
      id                 String    @id @default(uuid())
      rmaNumber          String    @unique
      status             RmaStatus @default(DRAFT)
      branchId           String
      customerId         String?
      submittedById      String
      cancellationReason String?
      rejectionReason    String?
      createdAt          DateTime  @default(now())
      updatedAt          DateTime  @updatedAt

      submittedBy User   @relation("SubmittedRmas", fields: [submittedById], references: [id])
      branch      Branch @relation(fields: [branchId], references: [id])
      lines       RmaLine[]
      auditEvents AuditEvent[] @relation("RmaAuditEvents")

      @@index([branchId])
      @@index([status])
      @@index([customerId])
      @@index([rmaNumber])
    }
    ```

    RmaLine model:
    ```prisma
    model RmaLine {
      id            String           @id @default(uuid())
      rmaId         String
      partNumber    String
      orderedQty    Int
      reasonCode    String
      disposition   DispositionType?
      receivedQty   Int              @default(0)
      inspectedQty  Int              @default(0)
      qcInspectedAt DateTime?
      createdAt     DateTime         @default(now())
      updatedAt     DateTime         @updatedAt

      rma Rma @relation(fields: [rmaId], references: [id], onDelete: Cascade)

      @@index([rmaId])
    }
    ```

    Update AuditEvent model — add the relation field for the back-reference (rmaId field already exists):
    ```prisma
    // Add inside the AuditEvent model body:
    rma Rma? @relation("RmaAuditEvents", fields: [rmaId], references: [id])
    ```

    Update User model — add the back-reference relation:
    ```prisma
    // Add inside the User model body:
    submittedRmas Rma[] @relation("SubmittedRmas")
    ```

    Update Branch model — add the back-reference relation:
    ```prisma
    // Add inside the Branch model body:
    rmas Rma[]
    ```

    After updating schema.prisma, run:
    ```bash
    cd rms-api && npx prisma validate
    cd rms-api && npx prisma generate
    ```

    If prisma validate fails, read the error carefully — most likely a missing @relation field or a naming collision. Fix and re-validate before proceeding.
  </action>
  <verify>
    <automated>cd "C:/Users/megan.delia/OneDrive - Master Electronics/Desktop/Claude Workshop/rms-api" && npx prisma validate && echo "SCHEMA_VALID" && npx prisma generate && echo "GENERATE_OK"</automated>
  </verify>
  <done>schema.prisma validates with no errors. npx prisma generate completes. The generated/prisma directory contains RmaStatus, DispositionType enums and typed Rma, RmaLine model operations.</done>
</task>

<task type="auto">
  <name>Task 2: Create rma.types.ts with all service input contracts</name>
  <files>rms-api/src/rma/rma.types.ts</files>
  <action>
    Create the src/rma/ directory and write rma.types.ts. This file defines all typed input shapes for RmaService methods. It is the interface contract that Plans 02, 03, 04 implement against — making service method signatures explicit and preventing any/unknown parameters.

    Create rms-api/src/rma/rma.types.ts:
    ```typescript
    import { RmsRole } from '../../generated/prisma/enums.js';

    // ----------------------------------------------------------------
    // Actor context — passed to every service method.
    // Comes from req.rmsUser (RmsAuthGuard output) in Phase 3.
    // Redeclared here to avoid circular import from users.service.ts.
    // ----------------------------------------------------------------
    export interface RmaActorContext {
      id: string;           // RMS User.id (UUID)
      portalUserId: string;
      email: string;
      role: RmsRole;
      branchIds: string[];
      isAdmin: boolean;
    }

    // ----------------------------------------------------------------
    // Line item inputs
    // ----------------------------------------------------------------

    // DispositionType matches the Prisma enum — re-exported for service consumers
    export { DispositionType } from '../../generated/prisma/enums.js';

    export interface LineInput {
      partNumber: string;       // non-empty string, e.g. "P-12345"
      orderedQty: number;       // positive integer
      reasonCode: string;       // structured code, e.g. "DEFECTIVE", "WRONG_ITEM"
      disposition?: string;     // DispositionType | undefined — optional at creation
    }

    export interface UpdateLineInput {
      partNumber?: string;
      orderedQty?: number;
      reasonCode?: string;
      disposition?: string | null;  // null explicitly clears disposition
    }

    export interface RecordReceiptInput {
      receivedQty: number;   // non-negative integer; over-receipt is allowed
    }

    export interface RecordQcInput {
      inspectedQty: number;  // must be <= receivedQty; service enforces
      qcNotes?: string;      // optional inspector notes; stored in audit newValue
    }

    // ----------------------------------------------------------------
    // RMA creation input
    // ----------------------------------------------------------------

    export interface CreateRmaInput {
      branchId: string;
      customerId?: string;    // nullable; internal RMAs may not have a customer
      lines: LineInput[];     // at least one line required at creation
    }

    // ----------------------------------------------------------------
    // Transition inputs for methods that require a reason string
    // ----------------------------------------------------------------

    export interface RejectRmaInput {
      rejectionReason: string;  // non-empty; required by LCYC-04
    }

    export interface CancelRmaInput {
      cancellationReason: string;  // non-empty; required by LCYC-11
    }

    export interface PlaceInfoRequiredInput {
      infoRequestNote?: string;  // optional context for the submitter; stored in audit
    }

    // ----------------------------------------------------------------
    // Invalid transition error shape (Claude's discretion)
    // ----------------------------------------------------------------

    // Thrown as BadRequestException with this body — consumers can inspect allowedTransitions
    export interface InvalidTransitionError {
      error: 'INVALID_TRANSITION';
      message: string;
      fromStatus: string;
      toStatus: string;
      allowedTransitions: string[];
    }
    ```

    After creating the file, verify TypeScript compiles by running a type check:
    ```bash
    cd rms-api && npx tsc --noEmit 2>&1 | head -20
    ```

    If there are import errors from the generated Prisma types (e.g., `enums.js` path not found), confirm that `npx prisma generate` was run in Task 1 first. The generated/prisma/enums.js must exist.
  </action>
  <verify>
    <automated>cd "C:/Users/megan.delia/OneDrive - Master Electronics/Desktop/Claude Workshop/rms-api" && npx tsc --noEmit 2>&1 | grep -c "error TS" | xargs -I{} test {} -eq 0 && echo "TYPES_OK"</automated>
  </verify>
  <done>rms-api/src/rma/rma.types.ts exists and exports: RmaActorContext, LineInput, UpdateLineInput, RecordReceiptInput, RecordQcInput, CreateRmaInput, RejectRmaInput, CancelRmaInput, PlaceInfoRequiredInput, InvalidTransitionError. TypeScript build passes with no errors.</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Schema validation: `cd rms-api && npx prisma validate` — must output no errors
2. Prisma generate: `cd rms-api && npx prisma generate` — must complete successfully
3. TypeScript build: `cd rms-api && npm run build` — must exit 0 with no TS errors
4. Enum check: `grep -n "RmaStatus\|DispositionType" rms-api/prisma/schema.prisma` — must show both enums
5. Model check: `grep -n "model Rma\|model RmaLine" rms-api/prisma/schema.prisma` — must show both models
6. QC timestamp field: `grep -n "qcInspectedAt" rms-api/prisma/schema.prisma` — must exist on RmaLine
7. Types file: `grep -n "export interface\|export {" rms-api/src/rma/rma.types.ts` — must show at least 8 exports
</verification>

<success_criteria>
- `npx prisma validate` exits 0 — schema is syntactically correct and relations are consistent
- `npx prisma generate` completes — typed Rma/RmaLine/RmaStatus/DispositionType available in generated/prisma
- `npm run build` exits 0 — rma.types.ts imports from generated/prisma/enums.js compile without error
- All 10 RmaStatus values present in schema
- All 4 DispositionType values present in schema
- RmaLine.qcInspectedAt DateTime? present — this is the per-line disposition lock trigger
- RmaLine.receivedQty and inspectedQty are Int @default(0) — integer tracking for LINE-03
- rma.types.ts exports typed input shapes for all service methods — Plans 02/03/04 can import them directly
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-rma-lifecycle/02-01-SUMMARY.md` with:
- Confirmation of schema validation passing
- List of enums and models added
- Confirmation of generated Prisma client containing new types
- List of types exported from rma.types.ts
- Any schema relation conflicts found and resolved
- TypeScript build pass confirmation
</output>
