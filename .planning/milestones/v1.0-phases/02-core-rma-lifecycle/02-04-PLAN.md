---
phase: 02-core-rma-lifecycle
plan: 04
type: execute
wave: 4
depends_on:
  - "02-03-PLAN"
files_modified:
  - rms-api/src/rma/rma.service.ts
autonomous: true
requirements:
  - LCYC-03
  - LCYC-04
  - LCYC-07
  - LCYC-08
  - LCYC-09
  - LCYC-10
  - LINE-03

must_haves:
  truths:
    - "Branch Manager can call approve() on a SUBMITTED RMA — RMA transitions to APPROVED with an audit event"
    - "Branch Manager can call reject() on a SUBMITTED RMA with a non-empty rejectionReason — RMA transitions to REJECTED"
    - "reject() throws BadRequestException when rejectionReason is empty or missing"
    - "Warehouse staff can call recordReceipt() on an APPROVED RMA — line's receivedQty is updated"
    - "The first recordReceipt() call on any line of an APPROVED RMA transitions the RMA status to RECEIVED"
    - "Subsequent recordReceipt() calls while the RMA is already RECEIVED update line quantities without re-transitioning"
    - "Over-receipt is allowed — receivedQty can exceed orderedQty with no error"
    - "QC staff can call recordQcInspection() on a RECEIVED RMA line — inspectedQty is set and qcInspectedAt is recorded"
    - "recordQcInspection() throws BadRequestException when inspectedQty would exceed the line's receivedQty"
    - "After all lines have qcInspectedAt set, completeQc() transitions RMA to QC_COMPLETE"
    - "resolve() transitions QC_COMPLETE to RESOLVED; close() transitions RESOLVED to CLOSED"
    - "TypeScript build passes with zero errors"
  artifacts:
    - path: "rms-api/src/rma/rma.service.ts"
      provides: "Complete RmaService with all 11 LCYC lifecycle methods and 3 LINE methods"
      exports: ["RmaService"]
  key_links:
    - from: "rms-api/src/rma/rma.service.ts"
      to: "rms-api/src/rma/rma.repository.ts"
      via: "recordReceipt calls rmaRepository.updateLineReceipt(tx) and conditionally rmaRepository.updateStatus(tx) for first-receipt transition"
      pattern: "isFirstReceipt"
    - from: "rms-api/src/rma/rma.service.ts"
      to: "rms-api/src/rma/rma-lifecycle.ts"
      via: "assertValidTransition called for every status change — approve, reject, recordReceipt (first receipt), completeQc, resolve, close"
      pattern: "assertValidTransition"
---

<objective>
Add the remaining lifecycle methods to RmaService: approve, reject (with required reason), recordReceipt (with first-receipt transition detection), recordQcInspection (with inspectedQty cap), completeQc, resolve, and close.

Purpose: This plan completes the full lifecycle chain — LCYC-03 through LCYC-10 and LINE-03 integer quantity tracking. The most complex method is recordReceipt, which must detect whether this is the first receipt on any line of the RMA and atomically transition status while updating the line quantity.

Output: rma.service.ts extended with 7 additional methods. All 11 LCYC requirements and all 3 LINE requirements are now fully implemented. TypeScript build passes.
</objective>

<execution_context>
@C:/Users/megan.delia/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/megan.delia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-core-rma-lifecycle/02-RESEARCH.md
@.planning/phases/02-core-rma-lifecycle/02-03-SUMMARY.md

<interfaces>
<!-- Current rma.service.ts state after Plan 03 — add methods below the existing ones -->

Existing methods in RmaService (Plan 03 output):
```typescript
createDraft(input: CreateRmaInput, actor: RmaActorContext): Promise<RmaWithLines>
submit(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
placeInfoRequired(rmaId: string, input: PlaceInfoRequiredInput, actor: RmaActorContext): Promise<RmaWithLines>
resubmit(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
cancel(rmaId: string, input: CancelRmaInput, actor: RmaActorContext): Promise<RmaWithLines>
addLine(rmaId: string, line: LineInput, actor: RmaActorContext): Promise<RmaWithLines>
updateLine(rmaId: string, lineId: string, data: UpdateLineInput, actor: RmaActorContext): Promise<RmaWithLines>
removeLine(rmaId: string, lineId: string, actor: RmaActorContext): Promise<RmaWithLines>
```

Repository methods used in this plan:
```typescript
// From rma.repository.ts:
findById(id: string): Promise<RmaWithLines | null>
updateStatus(tx, rmaId, status: RmaStatus): Promise<void>
updateRma(tx, rmaId, data: Prisma.RmaUpdateInput): Promise<void>
updateLineReceipt(tx, lineId, receivedQty): Promise<void>
updateLineQc(tx, lineId, inspectedQty): Promise<void>  // also sets qcInspectedAt
```

AuditAction values for this plan:
```typescript
AuditAction.RMA_APPROVED    // approve()
AuditAction.RMA_REJECTED    // reject()
AuditAction.RMA_RECEIVED    // recordReceipt() on first receipt
AuditAction.LINE_UPDATED    // recordReceipt() subsequent + recordQcInspection()
AuditAction.RMA_RESOLVED    // resolve()
AuditAction.RMA_CLOSED      // close()
// Note: AuditAction.STATUS_CHANGED can be used for completeQc() if preferred
```

LOCKED DECISIONS from CONTEXT.md for this plan:
- LCYC-07: First receipt on ANY line triggers RMA → RECEIVED immediately
- LCYC-07: Subsequent receipts while status is RECEIVED update qty without status change
- LCYC-07: Over-receipt allowed — receivedQty may exceed orderedQty (no upper bound)
- LINE-03: QC-inspected qty is capped at receivedQty per line — service rejects inspectedQty > receivedQty
- LINE-03: qcInspectedAt per line is the disposition lock trigger (already enforced in Plan 03)

First-receipt detection (from RESEARCH.md Pattern 4):
```typescript
// Before updating the line, check if ALL lines currently have receivedQty === 0
// If so, this is the first receipt — transition RMA to RECEIVED in the same tx
const isFirstReceipt = rma.lines.every((l) => l.receivedQty === 0);
```
IMPORTANT: This check happens BEFORE the line update (inside the transaction) to avoid TOCTOU race.
Both the line update and the conditional status update happen inside the same $transaction() call.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add approve and reject methods to RmaService</name>
  <files>rms-api/src/rma/rma.service.ts</files>
  <action>
    Open rms-api/src/rma/rma.service.ts (created in Plan 03) and append the approve() and reject() methods inside the RmaService class, after the existing removeLine() method.

    Add the following methods to the RmaService class:

    ```typescript
    // ----------------------------------------------------------------
    // LCYC-03: Approve a Submitted RMA
    // ----------------------------------------------------------------
    async approve(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines> {
      const rma = await this.rmaRepository.findById(rmaId);
      if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);

      assertValidTransition(rma.status, RmaStatus.APPROVED);

      return this.prisma.$transaction(async (tx) => {
        await this.rmaRepository.updateStatus(tx, rmaId, RmaStatus.APPROVED);

        await this.auditService.logEvent(tx, {
          rmaId,
          actorId: actor.id,
          actorRole: actor.role,
          action: AuditAction.RMA_APPROVED,
          fromStatus: rma.status,
          toStatus: RmaStatus.APPROVED,
        });

        return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
      });
    }

    // ----------------------------------------------------------------
    // LCYC-04: Reject a Submitted RMA with a required reason
    // ----------------------------------------------------------------
    async reject(
      rmaId: string,
      input: { rejectionReason: string },
      actor: RmaActorContext,
    ): Promise<RmaWithLines> {
      if (!input.rejectionReason || input.rejectionReason.trim().length === 0) {
        throw new BadRequestException('Rejection reason is required');
      }

      const rma = await this.rmaRepository.findById(rmaId);
      if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);

      assertValidTransition(rma.status, RmaStatus.REJECTED);

      return this.prisma.$transaction(async (tx) => {
        await this.rmaRepository.updateRma(tx, rmaId, {
          status: RmaStatus.REJECTED,
          rejectionReason: input.rejectionReason.trim(),
        });

        await this.auditService.logEvent(tx, {
          rmaId,
          actorId: actor.id,
          actorRole: actor.role,
          action: AuditAction.RMA_REJECTED,
          fromStatus: rma.status,
          toStatus: RmaStatus.REJECTED,
          newValue: { rejectionReason: input.rejectionReason.trim() },
        });

        return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
      });
    }
    ```

    After adding methods, run TypeScript check:
    ```bash
    cd rms-api && npx tsc --noEmit 2>&1 | grep "rma.service"
    ```
    No output = no errors.
  </action>
  <verify>
    <automated>cd "C:/Users/megan.delia/OneDrive - Master Electronics/Desktop/Claude Workshop/rms-api" && npx tsc --noEmit 2>&1 | grep -c "rma.service" | xargs -I{} test {} -eq 0 && echo "APPROVE_REJECT_OK"</automated>
  </verify>
  <done>approve() and reject() methods added to RmaService. reject() throws BadRequestException for empty rejectionReason. Both methods call assertValidTransition() and logEvent(tx) inside $transaction(). TypeScript reports no errors.</done>
</task>

<task type="auto">
  <name>Task 2: Add recordReceipt, recordQcInspection, completeQc, resolve, and close methods</name>
  <files>rms-api/src/rma/rma.service.ts</files>
  <action>
    Continue extending rms-api/src/rma/rma.service.ts by appending the remaining five methods after reject(). These methods complete the full LCYC-07 through LCYC-10 and LINE-03 requirements.

    Add these methods inside the RmaService class:

    ```typescript
    // ----------------------------------------------------------------
    // LCYC-07 + LINE-03: Record receipt on an Approved (or already Received) RMA line
    // ----------------------------------------------------------------
    async recordReceipt(
      rmaId: string,
      lineId: string,
      input: RecordReceiptInput,
      actor: RmaActorContext,
    ): Promise<RmaWithLines> {
      if (input.receivedQty < 0) {
        throw new BadRequestException('Received quantity cannot be negative');
      }

      const rma = await this.rmaRepository.findById(rmaId);
      if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);

      // Receipt is valid in APPROVED (first receipt transitions) or RECEIVED (subsequent receipts)
      if (rma.status !== RmaStatus.APPROVED && rma.status !== RmaStatus.RECEIVED) {
        throw new BadRequestException(
          `Cannot record receipt on an RMA in ${rma.status} status — must be APPROVED or RECEIVED`,
        );
      }

      const line = rma.lines.find((l) => l.id === lineId);
      if (!line) throw new NotFoundException(`Line ${lineId} not found on RMA ${rmaId}`);

      // LINE-03 guard: receivedQty cannot be set below existing inspectedQty
      // (over-receipt above orderedQty IS allowed — CONTEXT.md locked decision)
      if (input.receivedQty < line.inspectedQty) {
        throw new BadRequestException(
          `Cannot set receivedQty to ${input.receivedQty} — it would be below the already-inspected quantity of ${line.inspectedQty}`,
        );
      }

      // LCYC-07: First-receipt detection — if ALL lines have receivedQty === 0,
      // this is the first receipt on the RMA; transition to RECEIVED in the same tx.
      // Check is done before the update to avoid TOCTOU (Pitfall 3 from RESEARCH.md).
      const isFirstReceipt = rma.status === RmaStatus.APPROVED &&
        rma.lines.every((l) => l.receivedQty === 0);

      return this.prisma.$transaction(async (tx) => {
        // Update the line quantity
        await this.rmaRepository.updateLineReceipt(tx, lineId, input.receivedQty);

        // If first receipt: transition RMA status to RECEIVED atomically
        if (isFirstReceipt) {
          assertValidTransition(rma.status, RmaStatus.RECEIVED);
          await this.rmaRepository.updateStatus(tx, rmaId, RmaStatus.RECEIVED);
        }

        await this.auditService.logEvent(tx, {
          rmaId,
          rmaLineId: lineId,
          actorId: actor.id,
          actorRole: actor.role,
          action: AuditAction.RMA_RECEIVED,
          fromStatus: isFirstReceipt ? rma.status : undefined,
          toStatus: isFirstReceipt ? RmaStatus.RECEIVED : undefined,
          newValue: { receivedQty: input.receivedQty, isFirstReceipt },
        });

        return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
      });
    }

    // ----------------------------------------------------------------
    // LCYC-08 + LINE-03: Record QC inspection on a Received RMA line
    // ----------------------------------------------------------------
    async recordQcInspection(
      rmaId: string,
      lineId: string,
      input: RecordQcInput,
      actor: RmaActorContext,
    ): Promise<RmaWithLines> {
      const rma = await this.rmaRepository.findById(rmaId);
      if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);

      if (rma.status !== RmaStatus.RECEIVED) {
        throw new BadRequestException(
          `Cannot record QC inspection on an RMA in ${rma.status} status — must be RECEIVED`,
        );
      }

      const line = rma.lines.find((l) => l.id === lineId);
      if (!line) throw new NotFoundException(`Line ${lineId} not found on RMA ${rmaId}`);

      // LINE-03 guard: inspectedQty cannot exceed receivedQty (CONTEXT.md locked decision)
      if (input.inspectedQty > line.receivedQty) {
        throw new BadRequestException(
          `Cannot inspect ${input.inspectedQty} units — only ${line.receivedQty} units received on this line`,
        );
      }

      if (input.inspectedQty < 0) {
        throw new BadRequestException('Inspected quantity cannot be negative');
      }

      return this.prisma.$transaction(async (tx) => {
        // Sets inspectedQty and qcInspectedAt (disposition lock trigger)
        await this.rmaRepository.updateLineQc(tx, lineId, input.inspectedQty);

        await this.auditService.logEvent(tx, {
          rmaId,
          rmaLineId: lineId,
          actorId: actor.id,
          actorRole: actor.role,
          action: AuditAction.LINE_UPDATED,
          newValue: {
            inspectedQty: input.inspectedQty,
            qcNotes: input.qcNotes ?? null,
          },
        });

        return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
      });
    }

    // ----------------------------------------------------------------
    // LCYC-08 (completion): Transition RECEIVED → QC_COMPLETE
    // Called after QC staff have recorded inspection on all (or sufficient) lines.
    // ----------------------------------------------------------------
    async completeQc(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines> {
      const rma = await this.rmaRepository.findById(rmaId);
      if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);

      assertValidTransition(rma.status, RmaStatus.QC_COMPLETE);

      return this.prisma.$transaction(async (tx) => {
        await this.rmaRepository.updateStatus(tx, rmaId, RmaStatus.QC_COMPLETE);

        await this.auditService.logEvent(tx, {
          rmaId,
          actorId: actor.id,
          actorRole: actor.role,
          action: AuditAction.STATUS_CHANGED,
          fromStatus: rma.status,
          toStatus: RmaStatus.QC_COMPLETE,
        });

        return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
      });
    }

    // ----------------------------------------------------------------
    // LCYC-09: Resolve a QC-complete RMA
    // ----------------------------------------------------------------
    async resolve(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines> {
      const rma = await this.rmaRepository.findById(rmaId);
      if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);

      assertValidTransition(rma.status, RmaStatus.RESOLVED);

      return this.prisma.$transaction(async (tx) => {
        await this.rmaRepository.updateStatus(tx, rmaId, RmaStatus.RESOLVED);

        await this.auditService.logEvent(tx, {
          rmaId,
          actorId: actor.id,
          actorRole: actor.role,
          action: AuditAction.RMA_RESOLVED,
          fromStatus: rma.status,
          toStatus: RmaStatus.RESOLVED,
        });

        return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
      });
    }

    // ----------------------------------------------------------------
    // LCYC-10: Close a Resolved RMA
    // ----------------------------------------------------------------
    async close(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines> {
      const rma = await this.rmaRepository.findById(rmaId);
      if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);

      assertValidTransition(rma.status, RmaStatus.CLOSED);

      return this.prisma.$transaction(async (tx) => {
        await this.rmaRepository.updateStatus(tx, rmaId, RmaStatus.CLOSED);

        await this.auditService.logEvent(tx, {
          rmaId,
          actorId: actor.id,
          actorRole: actor.role,
          action: AuditAction.RMA_CLOSED,
          fromStatus: rma.status,
          toStatus: RmaStatus.CLOSED,
        });

        return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
      });
    }
    ```

    Also add the missing import for RecordReceiptInput and RecordQcInput at the top of the file (they were defined in rma.types.ts in Plan 01 but not yet imported in the service):
    ```typescript
    // Add to existing import from './rma.types.js':
    import {
      RmaActorContext,
      CreateRmaInput,
      LineInput,
      UpdateLineInput,
      CancelRmaInput,
      PlaceInfoRequiredInput,
      RecordReceiptInput,   // ADD
      RecordQcInput,        // ADD
    } from './rma.types.js';
    ```

    Run the full build:
    ```bash
    cd rms-api && npm run build 2>&1 | tail -20
    ```
    Must exit 0 with zero TypeScript errors.
  </action>
  <verify>
    <automated>cd "C:/Users/megan.delia/OneDrive - Master Electronics/Desktop/Claude Workshop/rms-api" && npm run build 2>&1 | grep -c "error TS" | xargs -I{} test {} -eq 0 && echo "FULL_SERVICE_BUILD_OK"</automated>
  </verify>
  <done>RmaService contains all 11 LCYC lifecycle methods (createDraft, submit, placeInfoRequired, resubmit, cancel, approve, reject, recordReceipt, recordQcInspection + completeQc, resolve, close) and 3 LINE methods (addLine, updateLine, removeLine). First-receipt detection in recordReceipt() uses isFirstReceipt guard inside $transaction(). inspectedQty > receivedQty throws BadRequestException. Over-receipt allowed (no upper bound on receivedQty). Full TypeScript build passes.</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Full build: `cd rms-api && npm run build` — must exit 0
2. Method count check:
   ```bash
   grep -c "async " rms-api/src/rma/rma.service.ts
   ```
   Must show 13+ (11 LCYC + 3 LINE methods, counting completeQc as part of LCYC-08)
3. First-receipt pattern:
   ```bash
   grep -n "isFirstReceipt" rms-api/src/rma/rma.service.ts
   ```
   Must show the detection logic (every(...receivedQty === 0)) and the conditional status update
4. inspectedQty cap:
   ```bash
   grep -n "inspectedQty.*receivedQty\|receivedQty.*inspectedQty" rms-api/src/rma/rma.service.ts
   ```
   Must show the guard that throws when inspectedQty > receivedQty
5. Rejection reason guard:
   ```bash
   grep -n "rejectionReason.*trim\|trim.*rejectionReason" rms-api/src/rma/rma.service.ts
   ```
   Must show the non-empty check
6. Audit events: `grep -c "logEvent(tx" rms-api/src/rma/rma.service.ts` — must be 13 (one per lifecycle + line method)
</verification>

<success_criteria>
- approve(): SUBMITTED → APPROVED with audit — LCYC-03 complete
- reject(): requires non-empty rejectionReason; SUBMITTED → REJECTED — LCYC-04 complete
- recordReceipt(): first receipt transitions APPROVED → RECEIVED; subsequent receipts update qty while in RECEIVED; inspectedQty lower bound enforced; over-receipt allowed — LCYC-07 + LINE-03 complete
- recordQcInspection(): inspectedQty capped at receivedQty; qcInspectedAt set on line (disposition lock trigger) — LCYC-08 + LINE-03 complete
- completeQc(): RECEIVED → QC_COMPLETE — LCYC-08 completion
- resolve(): QC_COMPLETE → RESOLVED — LCYC-09 complete
- close(): RESOLVED → CLOSED — LCYC-10 complete
- All 11 LCYC and 3 LINE requirements implemented across Plans 03 + 04
- Full TypeScript build passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-rma-lifecycle/02-04-SUMMARY.md` with:
- Complete list of all 13 RmaService methods with their LCYC/LINE requirement mappings
- Confirmation of first-receipt detection logic
- Confirmation of inspectedQty cap guard
- Confirmation of rejectionReason non-empty guard
- Confirmation of over-receipt allowed (no upper bound)
- TypeScript build pass confirmation
- Note on completeQc() as the explicit trigger for QC_COMPLETE transition (distinct from per-line recordQcInspection)
</output>
