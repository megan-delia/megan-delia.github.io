---
phase: 02-core-rma-lifecycle
plan: 02
type: execute
wave: 2
depends_on:
  - "02-01-PLAN"
files_modified:
  - rms-api/src/rma/rma-lifecycle.ts
  - rms-api/src/rma/rma.repository.ts
autonomous: true
requirements:
  - LCYC-01
  - LCYC-02
  - LCYC-03
  - LCYC-04
  - LCYC-05
  - LCYC-06
  - LCYC-07
  - LCYC-08
  - LCYC-09
  - LCYC-10
  - LCYC-11
  - LINE-01
  - LINE-02
  - LINE-03

must_haves:
  truths:
    - "assertValidTransition(DRAFT, SUBMITTED) does not throw — valid transition allowed"
    - "assertValidTransition(DRAFT, APPROVED) throws BadRequestException — invalid transition blocked"
    - "assertValidTransition(CANCELLED, DRAFT) throws BadRequestException — terminal states have no outgoing transitions"
    - "All terminal states (REJECTED, CANCELLED, CLOSED) have empty allowed-transition arrays"
    - "RmaRepository.findById() returns an Rma with its lines included, or null"
    - "RmaRepository.updateStatus() accepts a Prisma TransactionClient — it does NOT open its own transaction"
    - "TypeScript build passes with zero errors"
  artifacts:
    - path: "rms-api/src/rma/rma-lifecycle.ts"
      provides: "ALLOWED_TRANSITIONS const map and assertValidTransition() guard — the single authoritative state machine"
      exports: ["assertValidTransition", "ALLOWED_TRANSITIONS"]
    - path: "rms-api/src/rma/rma.repository.ts"
      provides: "All DB operations for RMA and line data; methods accept optional tx for transaction participation"
      exports: ["RmaRepository"]
  key_links:
    - from: "rms-api/src/rma/rma-lifecycle.ts"
      to: "rms-api/src/rma/rma.service.ts"
      via: "Every service lifecycle method calls assertValidTransition(from, to) before any DB write"
      pattern: "assertValidTransition"
    - from: "rms-api/src/rma/rma.repository.ts"
      to: "rms-api/src/rma/rma.service.ts"
      via: "Service calls rmaRepository.findById(rmaId) outside the transaction, then passes tx into update methods"
      pattern: "rmaRepository\\.find|rmaRepository\\.update"
---

<objective>
Implement the two foundational building blocks that all RmaService methods depend on: the state machine transition map (pure TypeScript const — no DB, no DI) and the RMA repository (all DB operations for Rma and RmaLine records).

Purpose: These two files are the data layer below the service. The transition map is a static data structure testable without any dependencies. The repository encapsulates all Prisma calls, accepts an optional `tx` parameter to participate in service-owned transactions, and is injected into RmaService via NestJS DI.

Output: rma-lifecycle.ts with ALLOWED_TRANSITIONS and assertValidTransition(); rma.repository.ts with all Rma/RmaLine query and mutation methods; TypeScript build passes.
</objective>

<execution_context>
@C:/Users/megan.delia/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/megan.delia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-core-rma-lifecycle/02-RESEARCH.md
@.planning/phases/02-core-rma-lifecycle/02-01-SUMMARY.md

<interfaces>
<!-- Types available after Plan 01 completes — use these directly -->

From rms-api/generated/prisma/enums.js (after npx prisma generate):
```typescript
export const RmaStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  INFO_REQUIRED: 'INFO_REQUIRED',
  APPROVED: 'APPROVED',
  RECEIVED: 'RECEIVED',
  QC_COMPLETE: 'QC_COMPLETE',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED',
};
export type RmaStatus = (typeof RmaStatus)[keyof typeof RmaStatus];

export const DispositionType: {
  CREDIT: 'CREDIT', REPLACEMENT: 'REPLACEMENT', SCRAP: 'SCRAP', RTV: 'RTV'
};
export type DispositionType = (typeof DispositionType)[keyof typeof DispositionType];
```

From rms-api/src/rma/rma.types.ts (Plan 01 output):
```typescript
export interface LineInput { partNumber: string; orderedQty: number; reasonCode: string; disposition?: string; }
export interface UpdateLineInput { partNumber?: string; orderedQty?: number; reasonCode?: string; disposition?: string | null; }
export interface RecordReceiptInput { receivedQty: number; }
export interface RecordQcInput { inspectedQty: number; qcNotes?: string; }
export interface CreateRmaInput { branchId: string; customerId?: string; lines: LineInput[]; }
```

From rms-api/src/prisma/prisma.service.ts:
```typescript
// PrismaService extends PrismaClient (Prisma 7 adapter pattern)
// Available via DI (global PrismaModule — no re-import needed)
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy
// Access via: this.prisma.rma.findUnique(...)
// Transaction: this.prisma.$transaction(async (tx) => { await tx.rma.update(...) })
```

From rms-api/src/audit/audit.service.ts:
```typescript
// MANDATORY: logEvent() requires a TransactionClient — never call with this.prisma directly
async logEvent(tx: Prisma.TransactionClient, input: AuditEventInput): Promise<void>
```

CRITICAL — NestJS DI constraint from STATE.md:
All new @Injectable() classes MUST use @Inject(Token) on every constructor parameter.
esbuild (Vitest bundler) does not emit design:paramtypes — without @Inject(), constructor
params are undefined in integration tests.
```typescript
// CORRECT:
@Injectable()
export class RmaRepository {
  constructor(@Inject(PrismaService) private readonly prisma: PrismaService) {}
}
// WRONG (causes undefined this.prisma in Vitest):
@Injectable()
export class RmaRepository {
  constructor(private readonly prisma: PrismaService) {}
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rma-lifecycle.ts — state machine transition map</name>
  <files>rms-api/src/rma/rma-lifecycle.ts</files>
  <action>
    Create the state machine as a pure TypeScript module with no NestJS DI, no Prisma, no side effects. This file is intentionally dependency-free — it is tested with plain Jest unit tests (no DB, no DI setup required).

    The ALLOWED_TRANSITIONS map encodes EVERY valid state change in the system. If a (from, to) pair is not listed, it is forbidden. assertValidTransition() throws BadRequestException with a structured body that includes the allowedTransitions array so API callers can see what transitions ARE valid.

    LOCKED DECISIONS from CONTEXT.md:
    - LCYC-11: DRAFT, SUBMITTED, APPROVED, and INFO_REQUIRED are all cancellable
    - LCYC-05: SUBMITTED → INFO_REQUIRED
    - LCYC-06: INFO_REQUIRED → SUBMITTED (resubmit)
    - Info Required is cancellable: INFO_REQUIRED → CANCELLED must be in the map

    Create rms-api/src/rma/rma-lifecycle.ts:
    ```typescript
    import { RmaStatus } from '../../generated/prisma/enums.js';
    import { BadRequestException } from '@nestjs/common';

    // Single authoritative source of truth for all valid RMA state transitions.
    // If a (from, to) pair is NOT in this map, the transition is forbidden.
    // Terminal states (REJECTED, CANCELLED, CLOSED) have empty arrays — no outgoing transitions.
    //
    // Design: Readonly<Record<RmaStatus, readonly RmaStatus[]>> means TypeScript
    // enforces that ALL RmaStatus values are present as keys (no missing states).
    export const ALLOWED_TRANSITIONS: Readonly<Record<RmaStatus, readonly RmaStatus[]>> = {
      [RmaStatus.DRAFT]:         [RmaStatus.SUBMITTED, RmaStatus.CANCELLED],
      [RmaStatus.SUBMITTED]:     [RmaStatus.APPROVED, RmaStatus.REJECTED, RmaStatus.INFO_REQUIRED, RmaStatus.CANCELLED],
      [RmaStatus.INFO_REQUIRED]: [RmaStatus.SUBMITTED, RmaStatus.CANCELLED],
      [RmaStatus.APPROVED]:      [RmaStatus.RECEIVED, RmaStatus.CANCELLED],
      [RmaStatus.RECEIVED]:      [RmaStatus.QC_COMPLETE],
      [RmaStatus.QC_COMPLETE]:   [RmaStatus.RESOLVED],
      [RmaStatus.RESOLVED]:      [RmaStatus.CLOSED],
      [RmaStatus.REJECTED]:      [],   // terminal — no further transitions
      [RmaStatus.CANCELLED]:     [],   // terminal — no further transitions
      [RmaStatus.CLOSED]:        [],   // terminal — no further transitions
    } as const;

    /**
     * Validates that transitioning from `from` to `to` is permitted.
     *
     * Throws BadRequestException with a structured body (InvalidTransitionError)
     * if the transition is not allowed. The allowedTransitions array in the error
     * body tells API callers which transitions ARE valid from the current state.
     *
     * Called at the top of every RmaService lifecycle method — before any DB write.
     */
    export function assertValidTransition(from: RmaStatus, to: RmaStatus): void {
      const allowed = ALLOWED_TRANSITIONS[from];
      if (!allowed.includes(to)) {
        throw new BadRequestException({
          error: 'INVALID_TRANSITION',
          message: `Cannot transition RMA from ${from} to ${to}`,
          fromStatus: from,
          toStatus: to,
          allowedTransitions: [...allowed],
        });
      }
    }
    ```

    After creating, verify it compiles:
    ```bash
    cd rms-api && npx tsc --noEmit 2>&1 | grep rma-lifecycle
    ```
    No output = no errors in this file.
  </action>
  <verify>
    <automated>cd "C:/Users/megan.delia/OneDrive - Master Electronics/Desktop/Claude Workshop/rms-api" && npx tsc --noEmit 2>&1 | grep -c "rma-lifecycle" | xargs -I{} test {} -eq 0 && echo "LIFECYCLE_OK"</automated>
  </verify>
  <done>rma-lifecycle.ts exports ALLOWED_TRANSITIONS (all 10 RmaStatus keys present) and assertValidTransition(). Terminal states (REJECTED, CANCELLED, CLOSED) have empty arrays. TypeScript compilation reports no errors in this file.</done>
</task>

<task type="auto">
  <name>Task 2: Create rma.repository.ts — all Rma and RmaLine DB operations</name>
  <files>rms-api/src/rma/rma.repository.ts</files>
  <action>
    Create the repository that owns all Prisma calls for RMA and RmaLine records. Service methods call the repository outside the transaction (for reads) and pass `tx` into repository mutation methods (for writes inside the transaction). This prevents nested transactions (Pitfall 6 from RESEARCH.md).

    Repository methods:
    - findById(id): finds Rma with lines included; returns null if not found
    - generateRmaNumber(): generates sequential human-readable number (RMA-YYYYMM-NNNNNN format)
    - createRma(tx, data): creates Rma with nested lines in a single write
    - updateStatus(tx, rmaId, status): updates Rma.status only
    - updateRma(tx, rmaId, data): updates multiple Rma fields (used for rejectionReason, cancellationReason)
    - addLine(tx, rmaId, line): adds a single line to an existing RMA
    - updateLine(tx, lineId, data): updates line fields
    - removeLine(tx, lineId): deletes a line
    - updateLineReceipt(tx, lineId, receivedQty): updates receivedQty on a line
    - updateLineQc(tx, lineId, data): updates inspectedQty and sets qcInspectedAt

    CRITICAL: All @Inject(Token) on every constructor parameter (esbuild constraint).

    Create rms-api/src/rma/rma.repository.ts:
    ```typescript
    import { Injectable, Inject } from '@nestjs/common';
    import { PrismaService } from '../prisma/prisma.service.js';
    import { Prisma, RmaStatus } from '../../generated/prisma/client.js';
    import { LineInput, UpdateLineInput } from './rma.types.js';

    // Full Rma record with lines included — returned by most service reads
    export type RmaWithLines = Prisma.RmaGetPayload<{ include: { lines: true } }>;

    @Injectable()
    export class RmaRepository {
      constructor(
        @Inject(PrismaService) private readonly prisma: PrismaService,
      ) {}

      /**
       * Find an RMA by ID, always including its lines.
       * Returns null (not throws) when not found — callers handle the null case.
       */
      async findById(id: string): Promise<RmaWithLines | null> {
        return this.prisma.rma.findUnique({
          where: { id },
          include: { lines: true },
        });
      }

      /**
       * Generate a unique, human-readable RMA number.
       * Format: RMA-YYYYMM-NNNNNN (zero-padded 6-digit sequence within the month).
       *
       * Uses COUNT(*) + 1 within the month prefix as the sequence.
       * On unique constraint violation (concurrent creation), caller retries.
       */
      async generateRmaNumber(): Promise<string> {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const prefix = `RMA-${year}${month}-`;

        const count = await this.prisma.rma.count({
          where: { rmaNumber: { startsWith: prefix } },
        });

        return `${prefix}${String(count + 1).padStart(6, '0')}`;
      }

      /**
       * Create an RMA with nested lines in a single round-trip.
       * Must be called inside a service $transaction — pass tx, not this.prisma.
       */
      async createRma(
        tx: Prisma.TransactionClient,
        data: {
          rmaNumber: string;
          branchId: string;
          customerId?: string;
          submittedById: string;
          lines: LineInput[];
        },
      ): Promise<RmaWithLines> {
        return tx.rma.create({
          data: {
            rmaNumber: data.rmaNumber,
            status: RmaStatus.DRAFT,
            branchId: data.branchId,
            customerId: data.customerId ?? null,
            submittedById: data.submittedById,
            lines: {
              create: data.lines.map((line) => ({
                partNumber: line.partNumber,
                orderedQty: line.orderedQty,
                reasonCode: line.reasonCode,
                disposition: (line.disposition as any) ?? null,
                receivedQty: 0,
                inspectedQty: 0,
              })),
            },
          },
          include: { lines: true },
        });
      }

      /**
       * Update the RMA status field only.
       * Must be called inside a service $transaction — pass tx.
       */
      async updateStatus(
        tx: Prisma.TransactionClient,
        rmaId: string,
        status: RmaStatus,
      ): Promise<void> {
        await tx.rma.update({
          where: { id: rmaId },
          data: { status },
        });
      }

      /**
       * Update multiple Rma fields (used for rejectionReason, cancellationReason, etc.).
       * Must be called inside a service $transaction — pass tx.
       */
      async updateRma(
        tx: Prisma.TransactionClient,
        rmaId: string,
        data: Prisma.RmaUpdateInput,
      ): Promise<void> {
        await tx.rma.update({ where: { id: rmaId }, data });
      }

      /**
       * Add a line to an existing RMA.
       * Called when a Returns Agent adds lines during DRAFT or INFO_REQUIRED.
       * Must be called inside a service $transaction — pass tx.
       */
      async addLine(
        tx: Prisma.TransactionClient,
        rmaId: string,
        line: LineInput,
      ): Promise<void> {
        await tx.rmaLine.create({
          data: {
            rmaId,
            partNumber: line.partNumber,
            orderedQty: line.orderedQty,
            reasonCode: line.reasonCode,
            disposition: (line.disposition as any) ?? null,
            receivedQty: 0,
            inspectedQty: 0,
          },
        });
      }

      /**
       * Update fields on an existing line.
       * Called for disposition updates and field edits in DRAFT or INFO_REQUIRED.
       * Must be called inside a service $transaction — pass tx.
       */
      async updateLine(
        tx: Prisma.TransactionClient,
        lineId: string,
        data: UpdateLineInput,
      ): Promise<void> {
        await tx.rmaLine.update({
          where: { id: lineId },
          data: {
            ...(data.partNumber !== undefined && { partNumber: data.partNumber }),
            ...(data.orderedQty !== undefined && { orderedQty: data.orderedQty }),
            ...(data.reasonCode !== undefined && { reasonCode: data.reasonCode }),
            // disposition: undefined = no change; null = explicit clear
            ...(data.disposition !== undefined && {
              disposition: (data.disposition as any),
            }),
          },
        });
      }

      /**
       * Remove a line. Only valid in DRAFT or INFO_REQUIRED (service enforces).
       * Must be called inside a service $transaction — pass tx.
       */
      async removeLine(tx: Prisma.TransactionClient, lineId: string): Promise<void> {
        await tx.rmaLine.delete({ where: { id: lineId } });
      }

      /**
       * Update the received quantity on a line.
       * Over-receipt is explicitly allowed — no max check here (CONTEXT.md decision).
       * Must be called inside a service $transaction — pass tx.
       */
      async updateLineReceipt(
        tx: Prisma.TransactionClient,
        lineId: string,
        receivedQty: number,
      ): Promise<void> {
        await tx.rmaLine.update({
          where: { id: lineId },
          data: { receivedQty },
        });
      }

      /**
       * Record QC inspection on a line.
       * Sets inspectedQty and qcInspectedAt (the disposition lock trigger).
       * Must be called inside a service $transaction — pass tx.
       */
      async updateLineQc(
        tx: Prisma.TransactionClient,
        lineId: string,
        inspectedQty: number,
      ): Promise<void> {
        await tx.rmaLine.update({
          where: { id: lineId },
          data: {
            inspectedQty,
            qcInspectedAt: new Date(),
          },
        });
      }
    }
    ```

    After creating, verify it compiles:
    ```bash
    cd rms-api && npx tsc --noEmit 2>&1 | grep rma.repository
    ```
    No output = no errors in this file.
  </action>
  <verify>
    <automated>cd "C:/Users/megan.delia/OneDrive - Master Electronics/Desktop/Claude Workshop/rms-api" && npx tsc --noEmit 2>&1 | grep -c "rma.repository" | xargs -I{} test {} -eq 0 && echo "REPOSITORY_OK"</automated>
  </verify>
  <done>rma.repository.ts exists with all required methods: findById, generateRmaNumber, createRma, updateStatus, updateRma, addLine, updateLine, removeLine, updateLineReceipt, updateLineQc. All constructor parameters use @Inject(PrismaService). TypeScript compilation reports no errors in this file.</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. TypeScript build: `cd rms-api && npm run build` — must exit 0
2. Transition map completeness:
   ```bash
   grep -c "RmaStatus\." rms-api/src/rma/rma-lifecycle.ts
   ```
   Should show 10+ occurrences (all 10 status keys in the map)
3. Terminal state check:
   ```bash
   grep -A1 "REJECTED\]\|CANCELLED\]\|CLOSED\]" rms-api/src/rma/rma-lifecycle.ts
   ```
   All three terminal states must have `[]` as their value
4. @Inject check:
   ```bash
   grep -n "@Inject" rms-api/src/rma/rma.repository.ts
   ```
   Must show @Inject(PrismaService) on the constructor parameter
5. No nested transaction: `grep -n "\$transaction" rms-api/src/rma/rma.repository.ts` — must return 0 matches (repository never opens its own transaction)
</verification>

<success_criteria>
- rma-lifecycle.ts: ALLOWED_TRANSITIONS covers all 10 RmaStatus values; DRAFT/SUBMITTED/APPROVED/INFO_REQUIRED all have CANCELLED as an allowed target (LCYC-11); REJECTED/CANCELLED/CLOSED have empty arrays
- rma.repository.ts: All 10 methods implemented; all accept Prisma.TransactionClient for mutation methods; RmaRepository constructor uses @Inject(PrismaService)
- No $transaction() calls in rma.repository.ts — prevents nested transaction pitfall
- TypeScript build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-rma-lifecycle/02-02-SUMMARY.md` with:
- ALLOWED_TRANSITIONS map summary (which states can reach which)
- List of repository methods created
- Confirmation of @Inject pattern applied
- Confirmation of no nested transactions in repository
- TypeScript build pass confirmation
</output>
