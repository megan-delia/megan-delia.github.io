---
phase: 02-core-rma-lifecycle
plan: 03
type: execute
wave: 3
depends_on:
  - "02-02-PLAN"
files_modified:
  - rms-api/src/rma/rma.module.ts
  - rms-api/src/rma/rma.service.ts
  - rms-api/src/app.module.ts
autonomous: true
requirements:
  - LCYC-01
  - LCYC-02
  - LCYC-05
  - LCYC-06
  - LCYC-11
  - LINE-01
  - LINE-02

must_haves:
  truths:
    - "Returns Agent can call createDraft() and get back an RMA in DRAFT status with its lines included and an audit event in the same transaction"
    - "Returns Agent can call submit() on a DRAFT RMA with at least one line — the RMA moves to SUBMITTED"
    - "Submitting a DRAFT RMA with zero lines throws a BadRequestException before touching the DB"
    - "Returns Agent can call cancel() on DRAFT, SUBMITTED, APPROVED, or INFO_REQUIRED RMAs with a non-empty reason"
    - "Cancelling without a reason string throws BadRequestException"
    - "Returns Agent can call placeInfoRequired() on a SUBMITTED RMA — RMA moves to INFO_REQUIRED"
    - "resubmit() transitions an INFO_REQUIRED RMA back to SUBMITTED and writes an audit event"
    - "addLine() and updateLine() are rejected (BadRequestException) when the RMA status is SUBMITTED or later (line lock)"
    - "Disposition can be set on a line at any time until qcInspectedAt IS NOT NULL (service enforces)"
    - "TypeScript build passes with zero errors"
  artifacts:
    - path: "rms-api/src/rma/rma.module.ts"
      provides: "NestJS module wiring RmaService and RmaRepository; imports AuditModule; exports RmaService"
      exports: ["RmaModule"]
    - path: "rms-api/src/rma/rma.service.ts"
      provides: "createDraft, submit, placeInfoRequired, resubmit, cancel, addLine, updateLine, removeLine service methods"
      exports: ["RmaService"]
  key_links:
    - from: "rms-api/src/rma/rma.service.ts"
      to: "rms-api/src/rma/rma-lifecycle.ts"
      via: "assertValidTransition() called at top of every lifecycle method before any DB write"
      pattern: "assertValidTransition"
    - from: "rms-api/src/rma/rma.service.ts"
      to: "rms-api/src/audit/audit.service.ts"
      via: "auditService.logEvent(tx, ...) called inside every prisma.$transaction()"
      pattern: "logEvent\\(tx"
    - from: "rms-api/src/rma/rma.module.ts"
      to: "rms-api/src/app.module.ts"
      via: "RmaModule imported in AppModule so RmaService is available application-wide"
      pattern: "RmaModule"
---

<objective>
Create the RmaModule (NestJS DI wiring) and the first half of RmaService: the draft/submit/cancel/info-required/resubmit lifecycle methods plus the line mutation methods (addLine, updateLine, removeLine). Wire RmaModule into AppModule.

Purpose: This plan implements LCYC-01, LCYC-02, LCYC-05, LCYC-06, LCYC-11 (create, submit, info-required, resubmit, cancel) and LINE-01, LINE-02 (line add/edit/remove with editability guards and disposition tracking). The atomic pattern is established here and repeated in Plan 04.

Output: rma.module.ts (DI wiring), rma.service.ts (7 lifecycle methods + 3 line methods), updated app.module.ts. TypeScript build passes.
</objective>

<execution_context>
@C:/Users/megan.delia/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/megan.delia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-core-rma-lifecycle/02-RESEARCH.md
@.planning/phases/02-core-rma-lifecycle/02-02-SUMMARY.md

<interfaces>
<!-- Types and contracts from Plans 01 and 02 — use these directly -->

From rms-api/src/rma/rma-lifecycle.ts (Plan 02):
```typescript
export function assertValidTransition(from: RmaStatus, to: RmaStatus): void
// Throws BadRequestException({ error: 'INVALID_TRANSITION', message, fromStatus, toStatus, allowedTransitions })
```

From rms-api/src/rma/rma.repository.ts (Plan 02):
```typescript
export type RmaWithLines = Prisma.RmaGetPayload<{ include: { lines: true } }>

export class RmaRepository {
  findById(id: string): Promise<RmaWithLines | null>
  generateRmaNumber(): Promise<string>
  createRma(tx, data: { rmaNumber, branchId, customerId?, submittedById, lines: LineInput[] }): Promise<RmaWithLines>
  updateStatus(tx, rmaId, status: RmaStatus): Promise<void>
  updateRma(tx, rmaId, data: Prisma.RmaUpdateInput): Promise<void>
  addLine(tx, rmaId, line: LineInput): Promise<void>
  updateLine(tx, lineId, data: UpdateLineInput): Promise<void>
  removeLine(tx, lineId): Promise<void>
}
```

From rms-api/src/rma/rma.types.ts (Plan 01):
```typescript
export interface RmaActorContext { id: string; portalUserId: string; email: string; role: RmsRole; branchIds: string[]; isAdmin: boolean; }
export interface CreateRmaInput { branchId: string; customerId?: string; lines: LineInput[]; }
export interface LineInput { partNumber: string; orderedQty: number; reasonCode: string; disposition?: string; }
export interface UpdateLineInput { partNumber?: string; orderedQty?: number; reasonCode?: string; disposition?: string | null; }
export interface RejectRmaInput { rejectionReason: string; }
export interface CancelRmaInput { cancellationReason: string; }
export interface PlaceInfoRequiredInput { infoRequestNote?: string; }
```

From rms-api/src/audit/audit.types.ts (Phase 1):
```typescript
// All Phase 2 AuditAction values already defined — use these:
AuditAction.RMA_CREATED     // createDraft
AuditAction.RMA_SUBMITTED   // submit + resubmit
AuditAction.RMA_INFO_REQUIRED // placeInfoRequired
AuditAction.RMA_CANCELLED   // cancel
AuditAction.LINE_ADDED      // addLine
AuditAction.LINE_UPDATED    // updateLine
AuditAction.DISPOSITION_SET // when disposition field changes
```

From rms-api/src/audit/audit.module.ts (Phase 1):
```typescript
// AuditModule exports AuditService — must be imported in RmaModule
@Module({ providers: [AuditService], exports: [AuditService] })
export class AuditModule {}
```

CRITICAL — NestJS DI constraint (STATE.md post-01-04):
Every constructor parameter in @Injectable() classes MUST use @Inject(Token).
Multi-module: RmaModule must explicitly import: [AuditModule] — @Global() does NOT propagate AuditService.
PrismaModule IS @Global() — PrismaService is available without importing PrismaModule.
```typescript
@Injectable()
export class RmaService {
  constructor(
    @Inject(PrismaService)    private readonly prisma: PrismaService,
    @Inject(AuditService)     private readonly auditService: AuditService,
    @Inject(RmaRepository)    private readonly rmaRepository: RmaRepository,
  ) {}
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rma.module.ts and wire into app.module.ts</name>
  <files>
    rms-api/src/rma/rma.module.ts
    rms-api/src/app.module.ts
  </files>
  <action>
    Create the RmaModule with explicit imports (AuditModule is required — it is not global). Then update AppModule to import RmaModule.

    Create rms-api/src/rma/rma.module.ts:
    ```typescript
    import { Module } from '@nestjs/common';
    import { RmaService } from './rma.service.js';
    import { RmaRepository } from './rma.repository.js';
    import { AuditModule } from '../audit/audit.module.js';

    @Module({
      imports: [AuditModule],       // AuditModule is NOT global — must explicitly import
      providers: [RmaService, RmaRepository],
      exports: [RmaService],        // Phase 3 controllers will inject RmaService
    })
    export class RmaModule {}
    ```

    Update rms-api/src/app.module.ts — add RmaModule to the imports array. Read the current app.module.ts first to preserve all existing imports (ConfigModule, LoggerModule, PrismaModule, UsersModule, AuthModule, AuditModule, MerpModule). Add RmaModule after MerpModule:
    ```typescript
    // Add to imports:
    import { RmaModule } from './rma/rma.module.js';
    // Add RmaModule to the @Module({ imports: [..., RmaModule] }) array
    ```

    Run TypeScript check after both files are written:
    ```bash
    cd rms-api && npx tsc --noEmit 2>&1 | grep "rma.module\|app.module"
    ```
  </action>
  <verify>
    <automated>cd "C:/Users/megan.delia/OneDrive - Master Electronics/Desktop/Claude Workshop/rms-api" && npx tsc --noEmit 2>&1 | grep -c "rma.module\|app.module" | xargs -I{} test {} -eq 0 && echo "MODULE_OK"</automated>
  </verify>
  <done>rma.module.ts exists with AuditModule in imports and [RmaService, RmaRepository] in providers. RmaModule is imported in app.module.ts. TypeScript reports no errors in either file.</done>
</task>

<task type="auto">
  <name>Task 2: Implement RmaService — createDraft, submit, placeInfoRequired, resubmit, cancel, and line operations</name>
  <files>rms-api/src/rma/rma.service.ts</files>
  <action>
    Implement the first seven lifecycle methods and three line mutation methods. Every method follows the same pattern: (1) fetch outside transaction, (2) validate transition, (3) validate business guards, (4) open transaction with DB write + audit log.

    LOCKED DECISIONS from CONTEXT.md:
    - Line items fully editable in DRAFT and INFO_REQUIRED; locked from SUBMITTED onward (addLine/updateLine/removeLine check status)
    - Cancellation requires a non-empty reason (LCYC-11)
    - Rejection requires a non-empty reason (LCYC-04 — implemented in Plan 04)
    - Info Required is cancellable (assertValidTransition handles this via the ALLOWED_TRANSITIONS map)
    - Disposition updatable until qcInspectedAt IS NOT NULL per line (check in updateLine)
    - No cycle limit on Info Required — resubmit() can be called any number of times
    - Resubmit mechanism: dedicated RmaService.resubmit() call (not implicit on update)

    Create rms-api/src/rma/rma.service.ts:
    ```typescript
    import { Injectable, Inject, BadRequestException, NotFoundException } from '@nestjs/common';
    import { PrismaService } from '../prisma/prisma.service.js';
    import { AuditService } from '../audit/audit.service.js';
    import { AuditAction } from '../audit/audit.types.js';
    import { RmaRepository, RmaWithLines } from './rma.repository.js';
    import { assertValidTransition } from './rma-lifecycle.js';
    import { RmaStatus } from '../../generated/prisma/enums.js';
    import {
      RmaActorContext,
      CreateRmaInput,
      LineInput,
      UpdateLineInput,
      CancelRmaInput,
      PlaceInfoRequiredInput,
    } from './rma.types.js';

    // Statuses in which line mutations (add/edit/remove) are permitted
    const LINE_EDITABLE_STATUSES: RmaStatus[] = [RmaStatus.DRAFT, RmaStatus.INFO_REQUIRED];

    @Injectable()
    export class RmaService {
      constructor(
        @Inject(PrismaService)  private readonly prisma: PrismaService,
        @Inject(AuditService)   private readonly auditService: AuditService,
        @Inject(RmaRepository)  private readonly rmaRepository: RmaRepository,
      ) {}

      // ----------------------------------------------------------------
      // LCYC-01 + LINE-01: Create Draft RMA with initial line items
      // ----------------------------------------------------------------
      async createDraft(input: CreateRmaInput, actor: RmaActorContext): Promise<RmaWithLines> {
        if (!input.lines || input.lines.length === 0) {
          throw new BadRequestException('At least one line item is required to create an RMA');
        }

        const rmaNumber = await this.rmaRepository.generateRmaNumber();

        return this.prisma.$transaction(async (tx) => {
          const rma = await this.rmaRepository.createRma(tx, {
            rmaNumber,
            branchId: input.branchId,
            customerId: input.customerId,
            submittedById: actor.id,
            lines: input.lines,
          });

          await this.auditService.logEvent(tx, {
            rmaId: rma.id,
            actorId: actor.id,
            actorRole: actor.role,
            action: AuditAction.RMA_CREATED,
            toStatus: RmaStatus.DRAFT,
            newValue: { rmaNumber: rma.rmaNumber, lineCount: rma.lines.length },
          });

          return rma;
        });
      }

      // ----------------------------------------------------------------
      // LCYC-02: Submit a Draft RMA
      // ----------------------------------------------------------------
      async submit(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines> {
        const rma = await this.rmaRepository.findById(rmaId);
        if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);

        assertValidTransition(rma.status, RmaStatus.SUBMITTED);

        // Guard: must have at least one line before submitting
        if (rma.lines.length === 0) {
          throw new BadRequestException('Cannot submit an RMA with no line items');
        }

        return this.prisma.$transaction(async (tx) => {
          await this.rmaRepository.updateStatus(tx, rmaId, RmaStatus.SUBMITTED);

          await this.auditService.logEvent(tx, {
            rmaId,
            actorId: actor.id,
            actorRole: actor.role,
            action: AuditAction.RMA_SUBMITTED,
            fromStatus: rma.status,
            toStatus: RmaStatus.SUBMITTED,
          });

          return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
        });
      }

      // ----------------------------------------------------------------
      // LCYC-05: Place RMA in Info Required
      // ----------------------------------------------------------------
      async placeInfoRequired(
        rmaId: string,
        input: PlaceInfoRequiredInput,
        actor: RmaActorContext,
      ): Promise<RmaWithLines> {
        const rma = await this.rmaRepository.findById(rmaId);
        if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);

        assertValidTransition(rma.status, RmaStatus.INFO_REQUIRED);

        return this.prisma.$transaction(async (tx) => {
          await this.rmaRepository.updateStatus(tx, rmaId, RmaStatus.INFO_REQUIRED);

          await this.auditService.logEvent(tx, {
            rmaId,
            actorId: actor.id,
            actorRole: actor.role,
            action: AuditAction.RMA_INFO_REQUIRED,
            fromStatus: rma.status,
            toStatus: RmaStatus.INFO_REQUIRED,
            newValue: input.infoRequestNote ? { note: input.infoRequestNote } : undefined,
          });

          return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
        });
      }

      // ----------------------------------------------------------------
      // LCYC-06: Resubmit from Info Required back to Submitted
      // ----------------------------------------------------------------
      async resubmit(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines> {
        const rma = await this.rmaRepository.findById(rmaId);
        if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);

        assertValidTransition(rma.status, RmaStatus.SUBMITTED);

        // Guard: must still have at least one line
        if (rma.lines.length === 0) {
          throw new BadRequestException('Cannot resubmit an RMA with no line items');
        }

        return this.prisma.$transaction(async (tx) => {
          await this.rmaRepository.updateStatus(tx, rmaId, RmaStatus.SUBMITTED);

          await this.auditService.logEvent(tx, {
            rmaId,
            actorId: actor.id,
            actorRole: actor.role,
            action: AuditAction.RMA_SUBMITTED,
            fromStatus: rma.status,
            toStatus: RmaStatus.SUBMITTED,
            metadata: { cycle: 'resubmit' },
          });

          return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
        });
      }

      // ----------------------------------------------------------------
      // LCYC-11: Cancel an RMA (DRAFT | SUBMITTED | APPROVED | INFO_REQUIRED)
      // ----------------------------------------------------------------
      async cancel(
        rmaId: string,
        input: CancelRmaInput,
        actor: RmaActorContext,
      ): Promise<RmaWithLines> {
        if (!input.cancellationReason || input.cancellationReason.trim().length === 0) {
          throw new BadRequestException('Cancellation reason is required');
        }

        const rma = await this.rmaRepository.findById(rmaId);
        if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);

        assertValidTransition(rma.status, RmaStatus.CANCELLED);

        return this.prisma.$transaction(async (tx) => {
          await this.rmaRepository.updateRma(tx, rmaId, {
            status: RmaStatus.CANCELLED,
            cancellationReason: input.cancellationReason.trim(),
          });

          await this.auditService.logEvent(tx, {
            rmaId,
            actorId: actor.id,
            actorRole: actor.role,
            action: AuditAction.RMA_CANCELLED,
            fromStatus: rma.status,
            toStatus: RmaStatus.CANCELLED,
            newValue: { cancellationReason: input.cancellationReason.trim() },
          });

          return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
        });
      }

      // ----------------------------------------------------------------
      // LINE-01: Add a line to an RMA in DRAFT or INFO_REQUIRED
      // ----------------------------------------------------------------
      async addLine(
        rmaId: string,
        line: LineInput,
        actor: RmaActorContext,
      ): Promise<RmaWithLines> {
        const rma = await this.rmaRepository.findById(rmaId);
        if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);

        if (!LINE_EDITABLE_STATUSES.includes(rma.status)) {
          throw new BadRequestException(
            `Cannot add lines to an RMA in ${rma.status} status — lines are locked after submission`,
          );
        }

        return this.prisma.$transaction(async (tx) => {
          await this.rmaRepository.addLine(tx, rmaId, line);

          await this.auditService.logEvent(tx, {
            rmaId,
            actorId: actor.id,
            actorRole: actor.role,
            action: AuditAction.LINE_ADDED,
            newValue: { partNumber: line.partNumber, orderedQty: line.orderedQty },
          });

          return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
        });
      }

      // ----------------------------------------------------------------
      // LINE-01 / LINE-02: Update a line (including disposition — LINE-02)
      // ----------------------------------------------------------------
      async updateLine(
        rmaId: string,
        lineId: string,
        data: UpdateLineInput,
        actor: RmaActorContext,
      ): Promise<RmaWithLines> {
        const rma = await this.rmaRepository.findById(rmaId);
        if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);

        if (!LINE_EDITABLE_STATUSES.includes(rma.status)) {
          throw new BadRequestException(
            `Cannot edit lines on an RMA in ${rma.status} status — lines are locked after submission`,
          );
        }

        const line = rma.lines.find((l) => l.id === lineId);
        if (!line) throw new NotFoundException(`Line ${lineId} not found on RMA ${rmaId}`);

        // LINE-02 guard: disposition locked after QC inspection on this specific line
        if (data.disposition !== undefined && line.qcInspectedAt !== null) {
          throw new BadRequestException(
            `Cannot update disposition on line ${lineId} — QC inspection has been recorded`,
          );
        }

        const isDispositionChange = data.disposition !== undefined;

        return this.prisma.$transaction(async (tx) => {
          await this.rmaRepository.updateLine(tx, lineId, data);

          await this.auditService.logEvent(tx, {
            rmaId,
            rmaLineId: lineId,
            actorId: actor.id,
            actorRole: actor.role,
            action: isDispositionChange ? AuditAction.DISPOSITION_SET : AuditAction.LINE_UPDATED,
            newValue: data as Record<string, unknown>,
          });

          return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
        });
      }

      // ----------------------------------------------------------------
      // LINE-01: Remove a line from an RMA in DRAFT or INFO_REQUIRED
      // ----------------------------------------------------------------
      async removeLine(
        rmaId: string,
        lineId: string,
        actor: RmaActorContext,
      ): Promise<RmaWithLines> {
        const rma = await this.rmaRepository.findById(rmaId);
        if (!rma) throw new NotFoundException(`RMA ${rmaId} not found`);

        if (!LINE_EDITABLE_STATUSES.includes(rma.status)) {
          throw new BadRequestException(
            `Cannot remove lines from an RMA in ${rma.status} status — lines are locked after submission`,
          );
        }

        const line = rma.lines.find((l) => l.id === lineId);
        if (!line) throw new NotFoundException(`Line ${lineId} not found on RMA ${rmaId}`);

        return this.prisma.$transaction(async (tx) => {
          await this.rmaRepository.removeLine(tx, lineId);

          await this.auditService.logEvent(tx, {
            rmaId,
            rmaLineId: lineId,
            actorId: actor.id,
            actorRole: actor.role,
            action: AuditAction.LINE_UPDATED,
            oldValue: { partNumber: line.partNumber, orderedQty: line.orderedQty, removed: true },
          });

          return this.rmaRepository.findById(rmaId) as Promise<RmaWithLines>;
        });
      }
    }
    ```

    After writing, run build to catch any import path or type errors:
    ```bash
    cd rms-api && npm run build 2>&1 | tail -15
    ```
  </action>
  <verify>
    <automated>cd "C:/Users/megan.delia/OneDrive - Master Electronics/Desktop/Claude Workshop/rms-api" && npm run build 2>&1 | grep -c "error TS" | xargs -I{} test {} -eq 0 && echo "SERVICE_BUILD_OK"</automated>
  </verify>
  <done>rma.service.ts exports RmaService with: createDraft, submit, placeInfoRequired, resubmit, cancel, addLine, updateLine, removeLine. All constructor parameters use @Inject(). All lifecycle methods call assertValidTransition() and auditService.logEvent(tx) inside prisma.$transaction(). Line editability is enforced (DRAFT/INFO_REQUIRED only). Disposition lock guard checks qcInspectedAt per line. Full TypeScript build passes.</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Full build: `cd rms-api && npm run build` — must exit 0
2. Module wiring: `grep -n "AuditModule\|RmaService\|RmaRepository" rms-api/src/rma/rma.module.ts` — must show all three
3. AppModule: `grep -n "RmaModule" rms-api/src/app.module.ts` — must show RmaModule import
4. @Inject check: `grep -c "@Inject(" rms-api/src/rma/rma.service.ts` — must be 3 (one per constructor param)
5. Transaction pattern: `grep -c "logEvent(tx" rms-api/src/rma/rma.service.ts` — must be 8 (one per method)
6. Cancellation reason guard: `grep -n "cancellationReason.*trim" rms-api/src/rma/rma.service.ts` — must find the non-empty check
7. Line lock guard: `grep -n "LINE_EDITABLE_STATUSES" rms-api/src/rma/rma.service.ts` — must appear in addLine, updateLine, removeLine
</verification>

<success_criteria>
- RmaModule imports AuditModule and provides [RmaService, RmaRepository]
- AppModule imports RmaModule
- createDraft() creates RMA + lines in a single $transaction() with an audit event — LCYC-01 + LINE-01
- submit() validates lines exist before transitioning to SUBMITTED — LCYC-02
- placeInfoRequired() transitions SUBMITTED → INFO_REQUIRED — LCYC-05
- resubmit() transitions INFO_REQUIRED → SUBMITTED — LCYC-06
- cancel() requires non-empty cancellationReason; works from DRAFT, SUBMITTED, APPROVED, INFO_REQUIRED — LCYC-11
- addLine()/updateLine()/removeLine() reject calls when status is not DRAFT or INFO_REQUIRED — LINE-01
- updateLine() rejects disposition change when qcInspectedAt IS NOT NULL on the line — LINE-02
- All methods use @Inject() on constructor params — Vitest DI safe
- Full TypeScript build passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-rma-lifecycle/02-03-SUMMARY.md` with:
- List of service methods implemented with their transition mappings
- Confirmation of @Inject() on all three constructor params
- Confirmation of auditService.logEvent(tx) inside every $transaction()
- Confirmation of line lock guard at LINE_EDITABLE_STATUSES
- Confirmation of disposition lock guard checking qcInspectedAt
- TypeScript build pass confirmation
</output>
