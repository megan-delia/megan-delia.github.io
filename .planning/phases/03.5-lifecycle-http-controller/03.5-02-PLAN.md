---
phase: 03.5-lifecycle-http-controller
plan: 02
type: execute
wave: 2
depends_on:
  - 03.5-01
files_modified:
  - rms-api/src/rma/lifecycle.controller.ts
  - rms-api/src/rma/rma.module.ts
autonomous: true
requirements:
  - LCYC-01
  - LCYC-02
  - LCYC-05
  - LCYC-06
  - LCYC-07
  - LCYC-08
  - LCYC-09
  - LCYC-10
  - LCYC-11
  - LINE-01
  - LINE-02
  - LINE-03
  - WKFL-04

must_haves:
  truths:
    - "Returns Agent can POST /rmas and receive a 201 with the created Draft RMA"
    - "Returns Agent can POST /rmas/:id/submit and the RMA transitions to SUBMITTED"
    - "WAREHOUSE role can POST /rmas/:id/lines/:lineId/receive to record receipt"
    - "QC role can POST /rmas/:id/complete-qc to transition RECEIVED → QC_COMPLETE"
    - "Finance + Returns Agent roles can POST /rmas/:id/resolve (Finance gate enforced by service)"
    - "Returns Agent can POST/PATCH/DELETE /rmas/:id/lines for line CRUD"
    - "Role mismatch returns 403 — e.g. WAREHOUSE calling POST /rmas is rejected"
  artifacts:
    - path: "rms-api/src/rma/lifecycle.controller.ts"
      provides: "All 14 Phase 2 lifecycle HTTP endpoints"
      exports: ["LifecycleController"]
    - path: "rms-api/src/rma/rma.module.ts"
      provides: "LifecycleController registered in NestJS module"
      contains: "LifecycleController"
  key_links:
    - from: "rms-api/src/rma/lifecycle.controller.ts POST /rmas"
      to: "rmaService.createDraft(result.data, req.rmsUser)"
      via: "Zod safeParse on CreateRmaBodySchema"
      pattern: "createDraft.*req.rmsUser"
    - from: "rms-api/src/rma/lifecycle.controller.ts GET /rmas/:id"
      to: "rmaRepository.findByIdBranchScoped(id, req.rmsUser)"
      via: "null check → NotFoundException"
      pattern: "findByIdBranchScoped"
    - from: "rms-api/src/rma/rma.module.ts"
      to: "rms-api/src/rma/lifecycle.controller.ts"
      via: "controllers array import"
      pattern: "LifecycleController"
---

<objective>
Create `lifecycle.controller.ts` — a NestJS controller under `@Controller('rmas')` that
exposes all 14 Phase 2 lifecycle service methods over HTTP with correct RBAC guards.
Then register it in RmaModule.

Purpose: Closes INT-01, INT-02, INT-03 from the v1.0 milestone audit. The service layer
is complete and tested — this plan wires it to HTTP. The controller is thin: Zod body
validation, `req.rmsUser` actor extraction, delegate to service, let NestJS exception
filter handle errors.

Output:
- `rms-api/src/rma/lifecycle.controller.ts` — 14 endpoints with per-method @Roles()
- `rms-api/src/rma/rma.module.ts` — updated controllers[] array
</objective>

<execution_context>
@C:/Users/megan.delia/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/megan.delia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.5-lifecycle-http-controller/03.5-RESEARCH.md
@.planning/phases/03.5-lifecycle-http-controller/03.5-01-SUMMARY.md
</context>

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From rms-api/src/rma/rma.service.ts (service method signatures — all confirmed HIGH confidence):
```typescript
createDraft(input: CreateRmaInput, actor: RmaActorContext): Promise<RmaWithLines>
// CreateRmaInput: { branchId: string; customerId?: string; lines: LineInput[] }

submit(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
// No body — rmaId from URL param only

placeInfoRequired(rmaId: string, input: PlaceInfoRequiredInput, actor: RmaActorContext): Promise<RmaWithLines>
// PlaceInfoRequiredInput: { infoRequestNote?: string }

resubmit(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
// No body

recordReceipt(rmaId: string, lineId: string, input: RecordReceiptInput, actor: RmaActorContext): Promise<RmaWithLines>
// RecordReceiptInput: { receivedQty: number }

completeQc(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
// No body

resolve(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
// No body — Finance gate enforced inside service (checks financeApprovedAt on all CREDIT lines)

close(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
// No body

cancel(rmaId: string, input: CancelRmaInput, actor: RmaActorContext): Promise<RmaWithLines>
// CancelRmaInput: { cancellationReason: string }

addLine(rmaId: string, line: LineInput, actor: RmaActorContext): Promise<RmaWithLines>
// LineInput: { partNumber: string; orderedQty: number; reasonCode: string; disposition?: string }

updateLine(rmaId: string, lineId: string, data: UpdateLineInput, actor: RmaActorContext): Promise<RmaWithLines>
// UpdateLineInput: { partNumber?: string; orderedQty?: number; reasonCode?: string; disposition?: string | null }

removeLine(rmaId: string, lineId: string, actor: RmaActorContext): Promise<RmaWithLines>
// No body
```

From rms-api/src/rma/rma.repository.ts (new methods from Plan 01):
```typescript
findManyBranchScoped(user: RmsUserContext, options?: { status?: RmaStatus; take?: number; skip?: number }): Promise<RmaWithLines[]>
findByIdBranchScoped(id: string, user: RmsUserContext): Promise<RmaWithLines | null>
```

From rms-api/src/rma/rma.controller.ts (established controller pattern to replicate):
```typescript
@Controller('rmas')
@UseGuards(RmsAuthGuard, RolesGuard)
export class RmaController {
  constructor(@Inject(RmaService) private readonly rmaService: RmaService) {}

  @Post(':id/contest')
  @Roles('CUSTOMER')
  async contest(@Param('id') id: string, @Body() body: unknown, @Req() req: Request & { rmsUser: RmsUserContext }) {
    const result = ContestBodySchema.safeParse(body);
    if (!result.success) throw new BadRequestException(result.error.flatten());
    return this.rmaService.contest(id, result.data, req.rmsUser);
  }
}
```

From rms-api/src/rma/rma.module.ts (current state):
```typescript
@Module({
  imports: [AuditModule],
  controllers: [RmaController, WorkflowController, FinanceController],
  providers: [RmaService, RmaRepository],
  exports: [RmaService],
})
export class RmaModule {}
```

Locked decisions from STATE.md:
- @Inject(Token) on ALL constructor params — Vitest esbuild strips design:paramtypes
- Zod .safeParse() exclusively — no class-validator, no ValidationPipe
- Thin controller — no business logic; let service throw BadRequestException/NotFoundException
- Per-method @Roles() only — roles vary per endpoint (not class-level like WorkflowController)
- Multiple controllers can share @Controller('rmas') prefix — NestJS routes by method+path
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Create lifecycle.controller.ts with all 14 endpoints</name>
  <files>rms-api/src/rma/lifecycle.controller.ts</files>
  <action>
Create `rms-api/src/rma/lifecycle.controller.ts` as a new file. The controller must
implement all 14 endpoints from the authoritative endpoint map.

Use the exact Zod schema names and shapes from the research file. Use per-method
@Roles() (NOT class-level) since roles differ across endpoints. @Inject() on both
constructor params is mandatory.

Complete file content:

```typescript
import {
  Controller, Get, Post, Patch, Delete,
  Param, Body, Query, Req,
  UseGuards, Inject,
  BadRequestException, NotFoundException,
} from '@nestjs/common';
import { z } from 'zod';
import { RmsAuthGuard } from '../auth/rms-auth.guard.js';
import { RolesGuard } from '../auth/roles.guard.js';
import { Roles } from '../auth/roles.decorator.js';
import { RmaService } from './rma.service.js';
import { RmaRepository } from './rma.repository.js';
import { branchScopeWhere } from '../users/users.service.js';
import type { RmsUserContext } from '../users/users.service.js';

// ---- Zod body schemas ----

const CreateRmaBodySchema = z.object({
  branchId: z.string().min(1),
  customerId: z.string().optional(),
  lines: z.array(z.object({
    partNumber: z.string().min(1),
    orderedQty: z.number().int().positive(),
    reasonCode: z.string().min(1),
    disposition: z.enum(['CREDIT', 'REPLACEMENT', 'SCRAP', 'RTV']).optional(),
  })).min(1, 'At least one line is required'),
});

const CancelBodySchema = z.object({
  cancellationReason: z.string().min(1, 'Cancellation reason is required'),
});

const InfoRequiredBodySchema = z.object({
  infoRequestNote: z.string().optional(),
});

const ReceiveBodySchema = z.object({
  receivedQty: z.number().int().min(0),
});

const AddLineBodySchema = z.object({
  partNumber: z.string().min(1),
  orderedQty: z.number().int().positive(),
  reasonCode: z.string().min(1),
  disposition: z.enum(['CREDIT', 'REPLACEMENT', 'SCRAP', 'RTV']).optional(),
});

const UpdateLineBodySchema = z.object({
  partNumber: z.string().optional(),
  orderedQty: z.number().int().positive().optional(),
  reasonCode: z.string().optional(),
  disposition: z.enum(['CREDIT', 'REPLACEMENT', 'SCRAP', 'RTV']).nullable().optional(),
});

// ---- Controller ----

@Controller('rmas')
@UseGuards(RmsAuthGuard, RolesGuard)
export class LifecycleController {
  constructor(
    @Inject(RmaService) private readonly rmaService: RmaService,
    @Inject(RmaRepository) private readonly rmaRepository: RmaRepository,
  ) {}

  // LCYC-01: Returns Agent creates a new Draft RMA
  @Post()
  @Roles('RETURNS_AGENT')
  async createDraft(
    @Body() body: unknown,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    const result = CreateRmaBodySchema.safeParse(body);
    if (!result.success) throw new BadRequestException(result.error.flatten());
    return this.rmaService.createDraft(result.data, req.rmsUser);
  }

  // GET /rmas — branch-scoped list (FOUND-03)
  @Get()
  @Roles('RETURNS_AGENT', 'BRANCH_MANAGER', 'ADMIN', 'FINANCE', 'QC', 'WAREHOUSE')
  async listRmas(
    @Query('status') status: string | undefined,
    @Query('take') take: string | undefined,
    @Query('skip') skip: string | undefined,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    return this.rmaRepository.findManyBranchScoped(req.rmsUser, {
      status: status as any,
      take: take ? parseInt(take, 10) : undefined,
      skip: skip ? parseInt(skip, 10) : undefined,
    });
  }

  // GET /rmas/:id — branch-scoped single (FOUND-03)
  @Get(':id')
  @Roles('RETURNS_AGENT', 'BRANCH_MANAGER', 'ADMIN', 'FINANCE', 'QC', 'WAREHOUSE')
  async getRma(
    @Param('id') id: string,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    const rma = await this.rmaRepository.findByIdBranchScoped(id, req.rmsUser);
    if (!rma) throw new NotFoundException(`RMA ${id} not found`);
    return rma;
  }

  // LCYC-02: Returns Agent or Customer submits a Draft RMA
  @Post(':id/submit')
  @Roles('RETURNS_AGENT', 'CUSTOMER')
  async submit(
    @Param('id') id: string,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    return this.rmaService.submit(id, req.rmsUser);
  }

  // LCYC-11: Returns Agent or Admin cancels with required reason
  @Post(':id/cancel')
  @Roles('RETURNS_AGENT', 'ADMIN')
  async cancel(
    @Param('id') id: string,
    @Body() body: unknown,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    const result = CancelBodySchema.safeParse(body);
    if (!result.success) throw new BadRequestException(result.error.flatten());
    return this.rmaService.cancel(id, result.data, req.rmsUser);
  }

  // LCYC-05: Returns Agent places RMA in Info Required
  @Post(':id/info-required')
  @Roles('RETURNS_AGENT')
  async placeInfoRequired(
    @Param('id') id: string,
    @Body() body: unknown,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    const result = InfoRequiredBodySchema.safeParse(body);
    if (!result.success) throw new BadRequestException(result.error.flatten());
    return this.rmaService.placeInfoRequired(id, result.data, req.rmsUser);
  }

  // LCYC-06: Returns Agent or Customer resubmits from Info Required
  @Post(':id/resubmit')
  @Roles('RETURNS_AGENT', 'CUSTOMER')
  async resubmit(
    @Param('id') id: string,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    return this.rmaService.resubmit(id, req.rmsUser);
  }

  // LCYC-08: QC staff triggers RECEIVED → QC_COMPLETE transition
  @Post(':id/complete-qc')
  @Roles('QC')
  async completeQc(
    @Param('id') id: string,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    return this.rmaService.completeQc(id, req.rmsUser);
  }

  // LCYC-09 + WKFL-04: Returns Agent or Finance resolves (Finance gate in service)
  @Post(':id/resolve')
  @Roles('RETURNS_AGENT', 'FINANCE')
  async resolve(
    @Param('id') id: string,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    return this.rmaService.resolve(id, req.rmsUser);
  }

  // LCYC-10: Returns Agent or Admin closes a Resolved RMA
  @Post(':id/close')
  @Roles('RETURNS_AGENT', 'ADMIN')
  async close(
    @Param('id') id: string,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    return this.rmaService.close(id, req.rmsUser);
  }

  // LCYC-07 + LINE-03: Warehouse records receipt per line
  @Post(':id/lines/:lineId/receive')
  @Roles('WAREHOUSE')
  async recordReceipt(
    @Param('id') id: string,
    @Param('lineId') lineId: string,
    @Body() body: unknown,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    const result = ReceiveBodySchema.safeParse(body);
    if (!result.success) throw new BadRequestException(result.error.flatten());
    return this.rmaService.recordReceipt(id, lineId, result.data, req.rmsUser);
  }

  // LINE-01: Returns Agent adds a line to a Draft/Info Required RMA
  @Post(':id/lines')
  @Roles('RETURNS_AGENT')
  async addLine(
    @Param('id') id: string,
    @Body() body: unknown,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    const result = AddLineBodySchema.safeParse(body);
    if (!result.success) throw new BadRequestException(result.error.flatten());
    return this.rmaService.addLine(id, result.data, req.rmsUser);
  }

  // LINE-01 + LINE-02: Returns Agent updates line fields including disposition
  @Patch(':id/lines/:lineId')
  @Roles('RETURNS_AGENT')
  async updateLine(
    @Param('id') id: string,
    @Param('lineId') lineId: string,
    @Body() body: unknown,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    const result = UpdateLineBodySchema.safeParse(body);
    if (!result.success) throw new BadRequestException(result.error.flatten());
    return this.rmaService.updateLine(id, lineId, result.data, req.rmsUser);
  }

  // LINE-01: Returns Agent removes a line from a Draft/Info Required RMA
  @Delete(':id/lines/:lineId')
  @Roles('RETURNS_AGENT')
  async removeLine(
    @Param('id') id: string,
    @Param('lineId') lineId: string,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    return this.rmaService.removeLine(id, lineId, req.rmsUser);
  }
}
```

Note: The `branchScopeWhere` import at line 13 is retained to support potential
future use, and because the research file includes it in the canonical skeleton.
If TypeScript reports it as unused, remove that import only (keep the `RmsUserContext`
type import).
  </action>
  <verify>
    <automated>cd "C:/Users/megan.delia/OneDrive - Master Electronics/Desktop/Claude Workshop/rms-api" && npm run build 2>&1 | tail -10</automated>
  </verify>
  <done>
lifecycle.controller.ts exists and compiles with 0 TypeScript errors. The file exports
LifecycleController with all 14 endpoint methods. @Inject() on both constructor params.
Per-method @Roles() only (no class-level @Roles). All service method calls match the
confirmed signatures from rma.service.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire LifecycleController into RmaModule</name>
  <files>rms-api/src/rma/rma.module.ts</files>
  <action>
Update `rms-api/src/rma/rma.module.ts` to import and register LifecycleController.

Current file (read first to confirm current state):
```typescript
import { Module } from '@nestjs/common';
import { AuditModule } from '../audit/audit.module.js';
import { RmaService } from './rma.service.js';
import { RmaRepository } from './rma.repository.js';
import { RmaController } from './rma.controller.js';
import { WorkflowController } from './workflow.controller.js';
import { FinanceController } from './finance.controller.js';

@Module({
  imports: [AuditModule],
  controllers: [RmaController, WorkflowController, FinanceController],
  providers: [RmaService, RmaRepository],
  exports: [RmaService],
})
export class RmaModule {}
```

Add import:
```typescript
import { LifecycleController } from './lifecycle.controller.js';
```

Update controllers array:
```typescript
controllers: [RmaController, WorkflowController, FinanceController, LifecycleController],
```

No other changes. Providers and exports stay identical. AuditModule import stays.
The .js extension is required — Node ESM resolution in this project uses .js on all
TypeScript source imports (confirmed by all existing import statements).
  </action>
  <verify>
    <automated>cd "C:/Users/megan.delia/OneDrive - Master Electronics/Desktop/Claude Workshop/rms-api" && npm run build 2>&1 | tail -5</automated>
  </verify>
  <done>
rma.module.ts contains "LifecycleController" in both the import statement and the
controllers array. `npm run build` exits 0. The file has exactly 5 imports and one
@Module decorator.
  </done>
</task>

</tasks>

<verification>
- `npm run build` exits 0 with no TypeScript errors
- `lifecycle.controller.ts` exists at `rms-api/src/rma/lifecycle.controller.ts`
- Controller has 14 methods covering all endpoints in the research endpoint map
- `@Inject(RmaService)` and `@Inject(RmaRepository)` present on constructor params
- No class-level `@Roles()` — per-method only
- `rma.module.ts` controllers array contains LifecycleController
- POST /rmas maps to createDraft (RETURNS_AGENT)
- POST /rmas/:id/lines/:lineId/receive maps to recordReceipt (WAREHOUSE)
- POST /rmas/:id/resolve maps to resolve (RETURNS_AGENT, FINANCE) — WKFL-04 gate
</verification>

<success_criteria>
- All 14 lifecycle HTTP endpoints are defined in lifecycle.controller.ts
- Controller is registered in RmaModule.controllers[]
- NestJS can discover all endpoints (confirmed by `npm run build` passing)
- Role assignments match the authoritative endpoint map from 03.5-RESEARCH.md exactly
- Finance gate (WKFL-04) is implicitly closed: POST /rmas/:id/resolve exists with
  correct roles; service already enforces the financeApprovedAt check internally
</success_criteria>

<output>
After completion, create `.planning/phases/03.5-lifecycle-http-controller/03.5-02-SUMMARY.md`
</output>
