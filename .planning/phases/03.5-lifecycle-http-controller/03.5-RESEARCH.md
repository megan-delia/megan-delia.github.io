# Phase 3.5: Lifecycle HTTP Controller - Research

**Researched:** 2026-02-27
**Domain:** NestJS controller authoring, RBAC guard wiring, Zod validation, branch-scoped reads — closing INT-01, INT-02, INT-03 from v1.0 milestone audit
**Confidence:** HIGH — all findings drawn directly from existing project source files; no external speculation needed

---

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| LCYC-01 | Returns Agent can create a new RMA in Draft status | `POST /rmas` → `rmaService.createDraft()` with `@Roles('RETURNS_AGENT')` |
| LCYC-02 | Returns Agent or Customer can submit a Draft RMA, transitioning it to Submitted | `POST /rmas/:id/submit` → `rmaService.submit()` with `@Roles('RETURNS_AGENT', 'CUSTOMER')` |
| LCYC-05 | Returns Agent can place an RMA in Info Required | `POST /rmas/:id/info-required` → `rmaService.placeInfoRequired()` with `@Roles('RETURNS_AGENT')` |
| LCYC-06 | Customer or staff can respond to Info Required, returning to Submitted | `POST /rmas/:id/resubmit` → `rmaService.resubmit()` with `@Roles('CUSTOMER', 'RETURNS_AGENT')` |
| LCYC-07 | Warehouse staff can record physical receipt on an Approved RMA | `POST /rmas/:id/lines/:lineId/receive` → `rmaService.recordReceipt()` with `@Roles('WAREHOUSE')` |
| LCYC-08 | QC staff can complete inspection on a Received RMA | `POST /rmas/:id/complete-qc` → `rmaService.completeQc()` with `@Roles('QC')` |
| LCYC-09 | Returns Agent or Finance can resolve a QC-complete RMA | `POST /rmas/:id/resolve` → `rmaService.resolve()` with `@Roles('RETURNS_AGENT', 'FINANCE')` |
| LCYC-10 | Returns Agent or Admin can close a Resolved RMA | `POST /rmas/:id/close` → `rmaService.close()` with `@Roles('RETURNS_AGENT', 'ADMIN')` |
| LCYC-11 | Returns Agent or Admin can cancel an RMA with required cancellation reason | `POST /rmas/:id/cancel` → `rmaService.cancel()` with `@Roles('RETURNS_AGENT', 'ADMIN')` |
| LINE-01 | Returns Agent can add multiple line items to an RMA | `POST /rmas/:id/lines` → `rmaService.addLine()` with `@Roles('RETURNS_AGENT')` |
| LINE-02 | Each RMA line can be assigned a disposition type | `PATCH /rmas/:id/lines/:lineId` → `rmaService.updateLine()` — disposition field in UpdateLineInput |
| LINE-03 | System tracks received and QC-inspected quantities as integers per line | Receipt: `POST /rmas/:id/lines/:lineId/receive`; QC: existing Phase 3 endpoint — integer body validation via Zod |
| WKFL-04 | Finance staff can view and approve credit-disposition lines before RMA transitions to Resolved | `POST /rmas/:id/resolve` blocks until all CREDIT lines have `financeApprovedAt` — service already enforces this gate |
</phase_requirements>

---

## Summary

Phase 3.5 is a pure HTTP wiring phase. All service methods are fully implemented and tested at the service layer. The only work is: (1) build `lifecycle.controller.ts` exposing the 12 missing Phase 2 service methods over HTTP with RBAC guards, (2) add two branch-scoped read endpoints (`GET /rmas` and `GET /rmas/:id`), and (3) wire the new controller into RmaModule. No new service logic, no schema changes, no new repository methods are needed.

The existing Phase 3 controllers (`rma.controller.ts`, `workflow.controller.ts`, `finance.controller.ts`) establish the exact patterns to follow: `@UseGuards(RmsAuthGuard, RolesGuard)` at class level, per-method `@Roles()` where roles differ, Zod schemas for body validation, `req.rmsUser` for the actor context, `@Inject()` decorators on all constructor parameters (mandatory for Vitest esbuild DI). The new controller must follow these patterns exactly.

The audit identified one additional gap that Phase 3.5 must close: `findById()` in `RmaRepository` has no branch-scope guard on the read path (FOUND-03 partial). The `GET /rmas/:id` read endpoint must apply `branchScopeWhere()` in its query rather than calling the raw `findById()` which has no ownership filter.

**Primary recommendation:** Create a single `lifecycle.controller.ts` under `src/rma/`, wire it into `RmaModule.controllers[]`, add it to the existing `@Controller('rmas')` prefix to coexist with `rma.controller.ts`, and add a branch-scoped `findMany` query to `RmaRepository` for the list endpoint.

---

## Standard Stack

### Core (already installed — no new packages needed)

| Library | Version | Purpose | Role in Phase 3.5 |
|---------|---------|---------|-------------------|
| @nestjs/common | ^11.0.1 | Controller decorators, guards, HTTP exceptions | All controller scaffolding |
| zod | ^4.3.6 | Request body validation | Inline schema objects per endpoint |
| @nestjs/testing | ^11.0.1 | TestingModule for integration tests | Integration test harness |
| vitest | ^4.0.18 | Integration test runner | `npm run test:e2e` |

**Installation:** No new packages required. All dependencies are present.

---

## Architecture Patterns

### Recommended Controller Location

```
rms-api/src/rma/
├── lifecycle.controller.ts    # NEW — Phase 3.5 controller
├── rma.controller.ts          # Phase 3 — contest, overturn, uphold, split, qc-inspection, approve-credit
├── workflow.controller.ts     # Phase 3 — approval queue + approve/reject
├── finance.controller.ts      # Phase 3 — credit queue
├── rma.service.ts             # Phase 2+3 service (no changes)
├── rma.repository.ts          # Phase 2+3 repository (add findManyBranchScoped)
├── rma.module.ts              # Add LifecycleController to controllers[] array
└── rma.types.ts               # No changes needed
```

### Pattern 1: Controller Skeleton (match Phase 3 exactly)

**What:** Class-level `@UseGuards` + `@Controller('rmas')`, per-method `@Roles()`, Zod body validation, `req.rmsUser` actor extraction, `@Inject()` on all constructor params.

**Source:** `rms-api/src/rma/rma.controller.ts` and `workflow.controller.ts`

```typescript
// Source: rms-api/src/rma/rma.controller.ts (Phase 3 pattern)
import {
  Controller, Get, Post, Patch, Delete, Param, Body, Query, Req,
  UseGuards, Inject, BadRequestException, NotFoundException, HttpCode,
} from '@nestjs/common';
import { z } from 'zod';
import { RmsAuthGuard } from '../auth/rms-auth.guard.js';
import { RolesGuard } from '../auth/roles.guard.js';
import { Roles } from '../auth/roles.decorator.js';
import { RmaService } from './rma.service.js';
import { RmaRepository } from './rma.repository.js';
import type { RmsUserContext } from '../users/users.service.js';
import { branchScopeWhere } from '../users/users.service.js';

@Controller('rmas')
@UseGuards(RmsAuthGuard, RolesGuard)
export class LifecycleController {
  constructor(
    @Inject(RmaService) private readonly rmaService: RmaService,
    @Inject(RmaRepository) private readonly rmaRepository: RmaRepository,
  ) {}
}
```

### Pattern 2: Zod Body Validation (match existing pattern exactly)

**What:** Define Zod schema as a `const` outside the class, call `.safeParse(body)`, throw `BadRequestException(result.error.flatten())` on failure.

**Source:** `rms-api/src/rma/rma.controller.ts` lines 13-28 and `workflow.controller.ts` lines 13-15

```typescript
// Source: rms-api/src/rma/workflow.controller.ts (lines 13-15, 59-62)
const RejectBodySchema = z.object({
  rejectionReason: z.string().min(1, 'Rejection reason is required'),
});

// In method:
const result = RejectBodySchema.safeParse(body);
if (!result.success) throw new BadRequestException(result.error.flatten());
return this.rmaService.reject(id, result.data, req.rmsUser);
```

### Pattern 3: RBAC — Per-Method @Roles() When Roles Differ

**What:** When a controller has endpoints with different role requirements, put `@UseGuards` at class level and `@Roles()` per method. Do NOT put `@Roles()` at class level if methods need different roles.

**Source:** `rms-api/src/rma/rma.controller.ts` (class has no class-level @Roles; each method has its own)

```typescript
// Source: rms-api/src/rma/rma.controller.ts (lines 37-43)
@Controller('rmas')
@UseGuards(RmsAuthGuard, RolesGuard)
export class RmaController {
  // Per-method roles — controller has multiple distinct roles
  @Post(':id/contest')
  @Roles('CUSTOMER')
  async contest(...) {}

  @Post(':id/overturn')
  @Roles('BRANCH_MANAGER')
  async overturn(...) {}
}
```

**Contrast:** `WorkflowController` uses class-level `@Roles('BRANCH_MANAGER')` because ALL methods share the same role. For `LifecycleController`, roles vary per endpoint — use per-method `@Roles()`.

### Pattern 4: HTTP Status Codes

**What:** NestJS default is 200 for all methods except POST which returns 201 by default. The existing controllers do NOT override this default — all POST mutations implicitly return 201. Transition endpoints (`submit`, `cancel`, etc.) return the updated RMA entity as the body.

**Source:** All three Phase 3 controllers — none use `@HttpCode()` decorator on POST methods, accepting the NestJS 201 default.

**Decision:** Follow the same pattern — do not add `@HttpCode(200)` to transition POSTs. The 201 default is acceptable for all `POST /rmas/:id/action` endpoints.

### Pattern 5: Branch-Scoped Read Endpoints (NEW — gap from audit)

**What:** `GET /rmas` and `GET /rmas/:id` must use `branchScopeWhere(user)` in their Prisma query. The existing `findById()` in `RmaRepository` does NOT apply branch scoping — a new repository method is needed.

**Source:** `rms-api/src/rma/rma.repository.ts` line 20-25 (findById — no branch filter)
**Source:** `rms-api/src/users/users.service.ts` lines 41-46 (branchScopeWhere definition)

```typescript
// Source: rms-api/src/rma/rma.repository.ts (existing findForApprovalQueue pattern)
// branchScopeWhere returns {} for Admin (no filter) or { branchId: { in: user.branchIds } }
const rows = await this.prisma.rma.findMany({
  where: {
    ...branchScopeWhere(user),    // ownership filter — always first
    // additional filters here
  },
  include: { lines: true },
});
```

### Pattern 6: @Inject() Mandatory on All Constructor Parameters

**What:** Vitest uses esbuild which does NOT emit `design:paramtypes` metadata. NestJS DI fails silently without `@Inject(Token)` on every constructor parameter.

**Source:** STATE.md decision: "post-01-04: Vitest+esbuild doesn't emit design:paramtypes — all NestJS constructor injections require explicit @Inject(Token) decorators"

```typescript
// CORRECT — always use @Inject()
constructor(
  @Inject(RmaService) private readonly rmaService: RmaService,
  @Inject(RmaRepository) private readonly rmaRepository: RmaRepository,
) {}

// WRONG — will fail in Vitest test environment
constructor(
  private readonly rmaService: RmaService,
  private readonly rmaRepository: RmaRepository,
) {}
```

### Anti-Patterns to Avoid

- **No-body @Roles on single-role controller + multi-role methods:** If methods have different roles, use per-method `@Roles()`, not class-level. Class-level `@Roles()` was used in `WorkflowController` only because ALL methods share `BRANCH_MANAGER`.
- **Business logic in controller:** The thin controller pattern is locked. Controllers call service methods only — no conditional logic, no DB queries (except via injected repository for read endpoints).
- **Raw findById() for read endpoints:** `findById()` has no branch scope guard. Use a new branch-scoped query method for `GET /rmas/:id` — throw `NotFoundException` if not found or not in scope (returning 404 for unauthorized reads, never 403, to avoid leaking existence).
- **ValidationPipe for body validation:** The project uses Zod exclusively for validation. ValidationPipe is registered globally as a no-op (audit finding). Do not add class-validator DTOs — use Zod schemas.
- **Missing @Inject() on constructor params:** Will cause NestJS DI failures in Vitest. Every param needs explicit `@Inject(Token)`.

---

## Complete Endpoint Map

This is the authoritative endpoint list derived from the audit's Gap 1-3 analysis and the REQUIREMENTS.md.

| HTTP Method | Path | Service Method | Roles | Body Schema |
|-------------|------|----------------|-------|-------------|
| POST | /rmas | createDraft | RETURNS_AGENT | CreateRmaBodySchema (branchId, customerId?, lines[]) |
| GET | /rmas | findManyBranchScoped (new repo method) | RETURNS_AGENT, BRANCH_MANAGER, ADMIN, FINANCE, QC, WAREHOUSE | Query: status?, take?, skip? |
| GET | /rmas/:id | findByIdBranchScoped (new repo method) | All roles | — |
| POST | /rmas/:id/submit | submit | RETURNS_AGENT, CUSTOMER | — (no body) |
| POST | /rmas/:id/cancel | cancel | RETURNS_AGENT, ADMIN | CancelBodySchema (cancellationReason) |
| POST | /rmas/:id/info-required | placeInfoRequired | RETURNS_AGENT | InfoRequiredBodySchema (infoRequestNote?) |
| POST | /rmas/:id/resubmit | resubmit | RETURNS_AGENT, CUSTOMER | — (no body) |
| POST | /rmas/:id/receive (lines/:lineId/receive) | recordReceipt | WAREHOUSE | ReceiveBodySchema (receivedQty) |
| POST | /rmas/:id/complete-qc | completeQc | QC | — (no body) |
| POST | /rmas/:id/resolve | resolve | RETURNS_AGENT, FINANCE | — (no body) |
| POST | /rmas/:id/close | close | RETURNS_AGENT, ADMIN | — (no body) |
| POST | /rmas/:id/lines | addLine | RETURNS_AGENT | AddLineBodySchema (partNumber, orderedQty, reasonCode, disposition?) |
| PATCH | /rmas/:id/lines/:lineId | updateLine | RETURNS_AGENT | UpdateLineBodySchema (partNumber?, orderedQty?, reasonCode?, disposition?) |
| DELETE | /rmas/:id/lines/:lineId | removeLine | RETURNS_AGENT | — (no body) |

**Note on recordReceipt path:** The audit specifies `POST /rmas/:id/receive` but the service takes a `lineId` parameter. The path should be `POST /rmas/:id/lines/:lineId/receive` to match the per-line receipt model (consistent with the existing `POST /rmas/:id/lines/:lineId/qc-inspection`).

---

## Complete Service Method Signatures

All signatures are drawn directly from `rms-api/src/rma/rma.service.ts` — HIGH confidence.

```typescript
// LCYC-01 + LINE-01
createDraft(input: CreateRmaInput, actor: RmaActorContext): Promise<RmaWithLines>
// CreateRmaInput: { branchId: string; customerId?: string; lines: LineInput[] }
// LineInput: { partNumber: string; orderedQty: number; reasonCode: string; disposition?: string }

// LCYC-02
submit(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
// No body input — rmaId from URL param only

// LCYC-05
placeInfoRequired(rmaId: string, input: PlaceInfoRequiredInput, actor: RmaActorContext): Promise<RmaWithLines>
// PlaceInfoRequiredInput: { infoRequestNote?: string }

// LCYC-06
resubmit(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
// No body input

// LCYC-07 + LINE-03
recordReceipt(rmaId: string, lineId: string, input: RecordReceiptInput, actor: RmaActorContext): Promise<RmaWithLines>
// RecordReceiptInput: { receivedQty: number }

// LCYC-08 completion
completeQc(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
// No body input

// LCYC-09 (WKFL-04 gate already in service)
resolve(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
// No body input — Finance gate enforced inside service

// LCYC-10
close(rmaId: string, actor: RmaActorContext): Promise<RmaWithLines>
// No body input

// LCYC-11
cancel(rmaId: string, input: CancelRmaInput, actor: RmaActorContext): Promise<RmaWithLines>
// CancelRmaInput: { cancellationReason: string }

// LINE-01 add
addLine(rmaId: string, line: LineInput, actor: RmaActorContext): Promise<RmaWithLines>

// LINE-01/LINE-02 update
updateLine(rmaId: string, lineId: string, data: UpdateLineInput, actor: RmaActorContext): Promise<RmaWithLines>
// UpdateLineInput: { partNumber?: string; orderedQty?: number; reasonCode?: string; disposition?: string | null }

// LINE-01 remove
removeLine(rmaId: string, lineId: string, actor: RmaActorContext): Promise<RmaWithLines>
```

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Request body validation | Manual type guards or try/catch | Zod `.safeParse()` — already used in all Phase 3 controllers | Consistent error shape, type-safe result.data |
| Role enforcement | If/switch on req.rmsUser.role in controller | `@Roles()` decorator + `RolesGuard` — already wired | Admin bypass is baked in; reflector reads method + class metadata |
| Branch ownership filter | Inline `branchId: { in: user.branchIds }` | `branchScopeWhere(user)` from users.service.ts — already used in repository | Admin receives `{}` (no filter) automatically; consistent pattern |
| Auth context extraction | Decode JWT in controller | `req.rmsUser` from `RmsAuthGuard` — already attached | Guards run before controller; rmsUser is guaranteed to exist |
| HTTP exception mapping | Try/catch with manual status codes | NestJS built-in exceptions (`BadRequestException`, `NotFoundException`) — already used in service | Service already throws these; controller can let them propagate |

**Key insight:** The service layer already handles all business logic including error throwing. Controllers should not add try/catch — NestJS's global exception filter handles `BadRequestException`, `NotFoundException`, and `ForbiddenException` automatically.

---

## Common Pitfalls

### Pitfall 1: Using findById() for Read Endpoints
**What goes wrong:** `GET /rmas/:id` calls `rmaRepository.findById(id)` directly — returns RMA from any branch, violating FOUND-03.
**Why it happens:** `findById()` was built for service-layer use (service already verified ownership before calling it). It has no branch filter.
**How to avoid:** Add a new `findByIdBranchScoped(id, user)` method to `RmaRepository` that applies `branchScopeWhere(user)` in the `where` clause. Return null → throw NotFoundException (404, not 403 — never reveal existence to unauthorized callers).
**Warning signs:** Audit explicitly flagged "findById() lacks branch-scope guard on read path" as cross-phase tech debt.

### Pitfall 2: Missing @Inject() on Constructor Parameters
**What goes wrong:** NestJS DI resolution fails in Vitest tests; constructor params are undefined at test time.
**Why it happens:** Vitest uses esbuild which strips TypeScript metadata; `design:paramtypes` is never emitted.
**How to avoid:** Always write `@Inject(RmaService)` etc. on every parameter. No exceptions.
**Warning signs:** STATE.md locked decision: "post-01-04: Vitest+esbuild doesn't emit design:paramtypes"

### Pitfall 3: Class-Level @Roles() When Methods Have Different Roles
**What goes wrong:** `@Roles('RETURNS_AGENT')` at class level blocks QC from calling `POST /complete-qc`, WAREHOUSE from calling `/receive`, etc.
**Why it happens:** Class-level `@Roles()` applies to every method. `RolesGuard` uses `getAllAndOverride` which checks handler first, then class — but if only class is set, every method inherits it.
**How to avoid:** `LifecycleController` has mixed roles across endpoints. Use per-method `@Roles()` only, no class-level `@Roles()`.
**Warning signs:** `WorkflowController` is the counterexample — it has class-level roles only because all methods share `BRANCH_MANAGER`.

### Pitfall 4: Forgetting to Register Controller in RmaModule
**What goes wrong:** NestJS never discovers the controller; endpoints return 404.
**Why it happens:** NestJS only routes to controllers listed in `controllers[]` of the owning module.
**How to avoid:** Add `LifecycleController` to `RmaModule.controllers` array alongside the three existing controllers.
**Warning signs:** `rma.module.ts` currently: `controllers: [RmaController, WorkflowController, FinanceController]`

### Pitfall 5: Route Collision on /rmas Prefix
**What goes wrong:** Both `rma.controller.ts` and `lifecycle.controller.ts` use `@Controller('rmas')`. NestJS handles this correctly — multiple controllers can share a prefix; routes are matched by method + path combination. This is NOT a problem.
**Why it matters:** Developers may incorrectly try to merge everything into `rma.controller.ts` to avoid the perceived collision. Do not do this — keep Phase 3 endpoints in `rma.controller.ts` and Phase 3.5 endpoints in `lifecycle.controller.ts` for clean separation.
**Warning signs:** All good — NestJS supports multiple controllers with the same prefix.

### Pitfall 6: recordReceipt Path Without lineId
**What goes wrong:** Defining `POST /rmas/:id/receive` without `:lineId` means the controller cannot pass a lineId to `rmaService.recordReceipt(rmaId, lineId, input, actor)`.
**Why it happens:** The audit's gap description says `POST /rmas/:id/receive` but that's shorthand. The service signature requires `lineId`.
**How to avoid:** Use `POST /rmas/:id/lines/:lineId/receive` to match the per-line model, consistent with the existing `POST /rmas/:id/lines/:lineId/qc-inspection`.

---

## Code Examples

### Complete Lifecycle Controller Skeleton

```typescript
// Source: rms-api/src/rma/lifecycle.controller.ts (to be created)
// Pattern derived from: rms-api/src/rma/rma.controller.ts + workflow.controller.ts

import {
  Controller, Get, Post, Patch, Delete, Param, Body, Query, Req,
  UseGuards, Inject, BadRequestException, NotFoundException,
} from '@nestjs/common';
import { z } from 'zod';
import { RmsAuthGuard } from '../auth/rms-auth.guard.js';
import { RolesGuard } from '../auth/roles.guard.js';
import { Roles } from '../auth/roles.decorator.js';
import { RmaService } from './rma.service.js';
import { RmaRepository } from './rma.repository.js';
import { branchScopeWhere } from '../users/users.service.js';
import type { RmsUserContext } from '../users/users.service.js';

// ---- Zod body schemas ----
const CreateRmaBodySchema = z.object({
  branchId: z.string().min(1),
  customerId: z.string().optional(),
  lines: z.array(z.object({
    partNumber: z.string().min(1),
    orderedQty: z.number().int().positive(),
    reasonCode: z.string().min(1),
    disposition: z.enum(['CREDIT', 'REPLACEMENT', 'SCRAP', 'RTV']).optional(),
  })).min(1, 'At least one line is required'),
});

const CancelBodySchema = z.object({
  cancellationReason: z.string().min(1, 'Cancellation reason is required'),
});

const InfoRequiredBodySchema = z.object({
  infoRequestNote: z.string().optional(),
});

const ReceiveBodySchema = z.object({
  receivedQty: z.number().int().min(0),
});

const AddLineBodySchema = z.object({
  partNumber: z.string().min(1),
  orderedQty: z.number().int().positive(),
  reasonCode: z.string().min(1),
  disposition: z.enum(['CREDIT', 'REPLACEMENT', 'SCRAP', 'RTV']).optional(),
});

const UpdateLineBodySchema = z.object({
  partNumber: z.string().optional(),
  orderedQty: z.number().int().positive().optional(),
  reasonCode: z.string().optional(),
  disposition: z.enum(['CREDIT', 'REPLACEMENT', 'SCRAP', 'RTV']).nullable().optional(),
});

@Controller('rmas')
@UseGuards(RmsAuthGuard, RolesGuard)
export class LifecycleController {
  constructor(
    @Inject(RmaService) private readonly rmaService: RmaService,
    @Inject(RmaRepository) private readonly rmaRepository: RmaRepository,
  ) {}

  // LCYC-01: Create Draft RMA
  @Post()
  @Roles('RETURNS_AGENT')
  async createDraft(
    @Body() body: unknown,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    const result = CreateRmaBodySchema.safeParse(body);
    if (!result.success) throw new BadRequestException(result.error.flatten());
    return this.rmaService.createDraft(result.data, req.rmsUser);
  }

  // Branch-scoped list
  @Get()
  @Roles('RETURNS_AGENT', 'BRANCH_MANAGER', 'ADMIN', 'FINANCE', 'QC', 'WAREHOUSE')
  async listRmas(
    @Query('status') status: string | undefined,
    @Query('take') take: string | undefined,
    @Query('skip') skip: string | undefined,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    return this.rmaRepository.findManyBranchScoped(req.rmsUser, {
      status: status as any,
      take: take ? parseInt(take, 10) : undefined,
      skip: skip ? parseInt(skip, 10) : undefined,
    });
  }

  // Branch-scoped get by ID
  @Get(':id')
  @Roles('RETURNS_AGENT', 'BRANCH_MANAGER', 'ADMIN', 'FINANCE', 'QC', 'WAREHOUSE')
  async getRma(
    @Param('id') id: string,
    @Req() req: Request & { rmsUser: RmsUserContext },
  ) {
    const rma = await this.rmaRepository.findByIdBranchScoped(id, req.rmsUser);
    if (!rma) throw new NotFoundException(`RMA ${id} not found`);
    return rma;
  }

  // ... remaining endpoints follow same pattern
}
```

### New Repository Methods (branch-scoped reads)

```typescript
// Source: rms-api/src/rma/rma.repository.ts — two new methods to add

// GET /rmas — branch-scoped list
async findManyBranchScoped(
  user: RmsUserContext,
  options?: { status?: RmaStatus; take?: number; skip?: number },
): Promise<RmaWithLines[]> {
  return this.prisma.rma.findMany({
    where: {
      ...branchScopeWhere(user),
      ...(options?.status ? { status: options.status } : {}),
    },
    include: { lines: true },
    orderBy: { createdAt: 'desc' },
    take: options?.take ?? 50,
    skip: options?.skip ?? 0,
  });
}

// GET /rmas/:id — branch-scoped single (returns null if not in scope)
async findByIdBranchScoped(id: string, user: RmsUserContext): Promise<RmaWithLines | null> {
  return this.prisma.rma.findFirst({
    where: {
      id,
      ...branchScopeWhere(user),
    },
    include: { lines: true },
  });
}
```

### RmaModule Update

```typescript
// Source: rms-api/src/rma/rma.module.ts — add LifecycleController
import { LifecycleController } from './lifecycle.controller.js';

@Module({
  imports: [AuditModule],
  controllers: [RmaController, WorkflowController, FinanceController, LifecycleController],
  providers: [RmaService, RmaRepository],
  exports: [RmaService],
})
export class RmaModule {}
```

### Integration Test Pattern (Vitest)

```typescript
// Source: rms-api/src/rma/workflow.integration.spec.ts (lines 1-80)
// Pattern: TestingModule + real DB + RBAC actor contexts

// @vitest-environment node
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { Test, TestingModule } from '@nestjs/testing';
import { ConfigModule } from '@nestjs/config';
import { PrismaModule } from '../prisma/prisma.module.js';
import { PrismaService } from '../prisma/prisma.service.js';
import { AuditModule } from '../audit/audit.module.js';
import { RmaModule } from './rma.module.js';
import { RmaService } from './rma.service.js';
import { RmaRepository } from './rma.repository.js';
import { RmaStatus, RmsRole } from '../../generated/prisma/client.js';
import { RmaActorContext } from './rma.types.js';

// Run: npm run test:e2e -- --reporter=verbose lifecycle.integration
```

---

## RmaModule Wiring Reference

Current state of `rms-api/src/rma/rma.module.ts`:
```typescript
@Module({
  imports: [AuditModule],       // AuditModule is NOT global — must explicitly import
  controllers: [RmaController, WorkflowController, FinanceController],
  providers: [RmaService, RmaRepository],
  exports: [RmaService],
})
export class RmaModule {}
```

Phase 3.5 change: Add `LifecycleController` to `controllers[]`. No other module changes needed — `RmaService` and `RmaRepository` are already provided.

---

## Validation Architecture

### Test Framework

| Property | Value |
|----------|-------|
| Framework | Vitest 4.0.18 (integration tests) + Jest 30 (unit tests) |
| Config file | `rms-api/vitest.integration.config.ts` |
| Quick run command | `cd rms-api && npm run test:e2e -- --reporter=verbose lifecycle.integration` |
| Full suite command | `cd rms-api && npm run test:all` |

### Phase Requirements → Test Map

| Req ID | Behavior | Test Type | Automated Command | File Exists? |
|--------|----------|-----------|-------------------|-------------|
| LCYC-01 | POST /rmas creates Draft RMA with lines | integration | `npm run test:e2e -- lifecycle.integration` | Wave 0 |
| LCYC-02 | POST /rmas/:id/submit transitions to SUBMITTED | integration | `npm run test:e2e -- lifecycle.integration` | Wave 0 |
| LCYC-05 | POST /rmas/:id/info-required transitions to INFO_REQUIRED | integration | `npm run test:e2e -- lifecycle.integration` | Wave 0 |
| LCYC-06 | POST /rmas/:id/resubmit from INFO_REQUIRED → SUBMITTED | integration | `npm run test:e2e -- lifecycle.integration` | Wave 0 |
| LCYC-07 | POST /rmas/:id/lines/:lineId/receive records receipt | integration | `npm run test:e2e -- lifecycle.integration` | Wave 0 |
| LCYC-08 | POST /rmas/:id/complete-qc transitions to QC_COMPLETE | integration | `npm run test:e2e -- lifecycle.integration` | Wave 0 |
| LCYC-09 | POST /rmas/:id/resolve (after finance gate) transitions to RESOLVED | integration | `npm run test:e2e -- lifecycle.integration` | Wave 0 |
| LCYC-10 | POST /rmas/:id/close transitions to CLOSED | integration | `npm run test:e2e -- lifecycle.integration` | Wave 0 |
| LCYC-11 | POST /rmas/:id/cancel with required reason | integration | `npm run test:e2e -- lifecycle.integration` | Wave 0 |
| LINE-01 | POST/PATCH/DELETE /rmas/:id/lines CRUD | integration | `npm run test:e2e -- lifecycle.integration` | Wave 0 |
| LINE-02 | PATCH /rmas/:id/lines/:lineId sets disposition | integration | `npm run test:e2e -- lifecycle.integration` | Wave 0 |
| LINE-03 | Integer quantity tracking via receive + QC endpoints | integration | `npm run test:e2e -- lifecycle.integration` | Wave 0 |
| WKFL-04 | resolve() blocked until all CREDIT lines have financeApprovedAt | integration | `npm run test:e2e -- lifecycle.integration` | Wave 0 |

Note: These tests call the service methods directly via TestingModule, identical to Phase 3's `workflow.integration.spec.ts`. HTTP layer RBAC is code-verified (same limitation noted in Phase 3 audit — requires live NestJS server to confirm at runtime).

### Sampling Rate

- **Per task commit:** `cd rms-api && npm run build` (TypeScript compile, no DB needed)
- **Per wave merge:** `cd rms-api && npm run test:all` (unit + integration, requires Docker)
- **Phase gate:** Full suite green + `npm run build` 0 errors before `/gsd:verify-work`

### Wave 0 Gaps

- [ ] `src/rma/lifecycle.controller.ts` — the controller itself (Wave 1 task)
- [ ] `src/rma/lifecycle.integration.spec.ts` — integration tests covering all 13 requirements
- [ ] Two new repository methods in `rma.repository.ts`: `findManyBranchScoped` and `findByIdBranchScoped`

*(No framework install or config gaps — Vitest and Jest are fully configured)*

---

## State of the Art

| Old Approach | Current Approach | Notes |
|--------------|------------------|-------|
| class-validator DTOs with ValidationPipe | Zod `.safeParse()` schemas | Project uses Zod exclusively; ValidationPipe is a registered no-op |
| separate e2e HTTP test server | NestJS TestingModule with direct service calls | Matches Phase 3 pattern; HTTP RBAC verification deferred to runtime smoke test |

**Confirmed current:** Zod 4.3.6 is installed. The `z.enum()` syntax in Phase 3 controllers confirms Zod v4 API is in use.

---

## Open Questions

1. **GET /rmas role gating — should CUSTOMER role be included?**
   - What we know: CUSTOMER role is not in the Phase 3.5 requirement list for GET /rmas. Phase 6 (Customer Self-Service Portal) will handle customer-facing list.
   - What's unclear: Should CUSTOMER be blocked at the controller level now, or just return an empty branch-scoped list (customers have no branchIds)?
   - Recommendation: Exclude CUSTOMER from `@Roles()` on GET /rmas for now. Phase 6 will add customer-specific endpoints. If they somehow call it, `branchScopeWhere` would return `{ branchId: { in: [] } }` (empty set) — no data would leak.

2. **No-body POST endpoints — should body be accepted and ignored?**
   - What we know: `submit`, `resubmit`, `completeQc`, `resolve`, `close` take no body. Phase 3 `approve` endpoint also takes no body and works fine.
   - Recommendation: Do not add `@Body()` parameter to these methods. NestJS handles missing body gracefully. No body schema needed.

3. **List endpoint response shape — RmaWithLines or lightweight summary?**
   - What we know: `findManyBranchScoped` returning full `RmaWithLines` is simplest. The approval queue returns a lightweight projection; GET /rmas is not specified to be lightweight.
   - Recommendation: Return `RmaWithLines` (with lines included) for Phase 3.5. Phase 5 (Workspace and Dashboards) will optimize with projections and pagination.

---

## Sources

### Primary (HIGH confidence)

- `rms-api/src/rma/rma.controller.ts` — Zod validation pattern, per-method @Roles(), thin controller pattern
- `rms-api/src/rma/workflow.controller.ts` — class-level @Roles(), guard chain pattern, approval queue
- `rms-api/src/rma/finance.controller.ts` — single-role controller pattern
- `rms-api/src/rma/rma.service.ts` — all service method signatures and input types (complete)
- `rms-api/src/rma/rma.repository.ts` — branchScopeWhere usage, findById gap, existing query patterns
- `rms-api/src/rma/rma.module.ts` — current controllers[] array, module wiring
- `rms-api/src/rma/rma.types.ts` — all input/output type contracts
- `rms-api/src/auth/rms-auth.guard.ts` — RmsAuthGuard behavior, rmsUser attachment
- `rms-api/src/auth/roles.guard.ts` — RolesGuard behavior, getAllAndOverride, admin bypass
- `rms-api/src/auth/roles.decorator.ts` — @Roles() implementation
- `rms-api/src/users/users.service.ts` — branchScopeWhere() implementation, RmsUserContext type
- `.planning/v1.0-MILESTONE-AUDIT.md` — INT-01, INT-02, INT-03 gap definitions and evidence
- `.planning/REQUIREMENTS.md` — requirement descriptions and role assignments
- `.planning/STATE.md` — locked decisions (Vitest @Inject requirement, Zod-only validation, thin controller pattern)
- `rms-api/vitest.integration.config.ts` — test runner config
- `rms-api/src/rma/workflow.integration.spec.ts` — integration test pattern to replicate

### Secondary (MEDIUM confidence)

- None required — all findings are from authoritative project source files

### Tertiary (LOW confidence)

- None

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — no new packages; all existing dependencies confirmed from package.json
- Architecture: HIGH — patterns copied directly from Phase 3 source files; no guesswork
- Pitfalls: HIGH — drawn from audit findings (findById gap), STATE.md locked decisions (@Inject rule), and Phase 3 controller source analysis
- Endpoint map: HIGH — derived from audit INT-01/INT-02/INT-03 gap specification + service signatures
- Test map: HIGH — Vitest config and integration test pattern confirmed from existing spec files

**Research date:** 2026-02-27
**Valid until:** 2026-03-29 (30 days — stack is stable; no external dependencies)
