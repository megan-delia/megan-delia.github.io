---
phase: 03.5-lifecycle-http-controller
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rms-api/src/rma/rma.repository.ts
autonomous: true
requirements:
  - LCYC-01
  - LCYC-02
  - LCYC-05
  - LCYC-06
  - LCYC-07
  - LCYC-08
  - LCYC-09
  - LCYC-10
  - LCYC-11
  - LINE-01
  - LINE-02
  - LINE-03

must_haves:
  truths:
    - "GET /rmas returns only RMAs belonging to the requesting user's branch — never cross-branch records"
    - "GET /rmas/:id returns 404 (not 403) when the RMA exists but belongs to another branch"
    - "Admin users receive all RMAs with no branch filter on GET /rmas"
  artifacts:
    - path: "rms-api/src/rma/rma.repository.ts"
      provides: "findManyBranchScoped and findByIdBranchScoped methods"
      contains: "findManyBranchScoped"
  key_links:
    - from: "rms-api/src/rma/rma.repository.ts findByIdBranchScoped"
      to: "branchScopeWhere(user)"
      via: "prisma.rma.findFirst with spread branchScopeWhere in where clause"
      pattern: "findFirst.*branchScopeWhere"
    - from: "rms-api/src/rma/rma.repository.ts findManyBranchScoped"
      to: "branchScopeWhere(user)"
      via: "prisma.rma.findMany with spread branchScopeWhere in where clause"
      pattern: "findMany.*branchScopeWhere"
---

<objective>
Add two branch-scoped read methods to RmaRepository so lifecycle.controller.ts can
implement GET /rmas and GET /rmas/:id with correct data-ownership enforcement.

Purpose: The existing `findById()` method has no branch filter — it returns any RMA
regardless of the caller's branch. The audit (INT-01/FOUND-03) flagged this as a read
path gap. These two new methods close that gap by applying `branchScopeWhere(user)` in
the Prisma query, consistent with every other branch-scoped query in the repository.

Output:
- `findManyBranchScoped(user, options?)` — paginated list of branch-scoped RMAs with lines
- `findByIdBranchScoped(id, user)` — single RMA by ID filtered to caller's branches
</objective>

<execution_context>
@C:/Users/megan.delia/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/megan.delia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.5-lifecycle-http-controller/03.5-RESEARCH.md
</context>

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

From rms-api/src/rma/rma.repository.ts (existing pattern to match):
```typescript
import { RmsUserContext, branchScopeWhere } from '../users/users.service.js';
export type RmaWithLines = Prisma.RmaGetPayload<{ include: { lines: true } }>;

// Existing branch-scoped query pattern (findForApprovalQueue):
const rows = await this.prisma.rma.findMany({
  where: {
    ...branchScopeWhere(user),   // ownership filter — always first; Admin gets {} (no filter)
    status: { in: statusFilter },
  },
  take: options?.take ?? 50,
  skip: options?.skip ?? 0,
});

// Existing unscoped method (has no branch filter — DO NOT use for read endpoints):
async findById(id: string): Promise<RmaWithLines | null> {
  return this.prisma.rma.findUnique({ where: { id }, include: { lines: true } });
}
```

From rms-api/src/users/users.service.ts (branchScopeWhere contract):
```typescript
// branchScopeWhere returns {} for Admin (isAdmin=true, no filter applied)
// or { branchId: { in: user.branchIds } } for all other roles
export function branchScopeWhere(user: RmsUserContext): Prisma.RmaWhereInput;
```

From rms-api/src/rma/rma.types.ts:
```typescript
export interface RmaActorContext { ... }  // service-layer shape
// RmsUserContext is the repository/controller-layer shape — from users.service.ts
```

From generated/prisma/client.js:
```typescript
import { RmaStatus } from '../../generated/prisma/client.js';
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Add findManyBranchScoped to RmaRepository</name>
  <files>rms-api/src/rma/rma.repository.ts</files>
  <action>
Add a new method `findManyBranchScoped` to the RmaRepository class after the existing
`findCreditApprovalLines` method. The method signature and implementation must exactly
match the research pattern:

```typescript
async findManyBranchScoped(
  user: RmsUserContext,
  options?: { status?: RmaStatus; take?: number; skip?: number },
): Promise<RmaWithLines[]> {
  return this.prisma.rma.findMany({
    where: {
      ...branchScopeWhere(user),
      ...(options?.status ? { status: options.status } : {}),
    },
    include: { lines: true },
    orderBy: { createdAt: 'desc' },
    take: options?.take ?? 50,
    skip: options?.skip ?? 0,
  });
}
```

The `branchScopeWhere(user)` call is already imported at line 5 of rma.repository.ts —
no new import needed. `RmaStatus` is already imported at line 3. `RmaWithLines` is
declared at line 8.

Do NOT change any existing methods. Append after the closing brace of
`findCreditApprovalLines`.
  </action>
  <verify>
    <automated>cd "C:/Users/megan.delia/OneDrive - Master Electronics/Desktop/Claude Workshop/rms-api" && npm run build 2>&1 | tail -5</automated>
  </verify>
  <done>
rma.repository.ts compiles with 0 TypeScript errors. The file contains the string
"findManyBranchScoped" as a public async method. All existing methods are unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add findByIdBranchScoped to RmaRepository</name>
  <files>rms-api/src/rma/rma.repository.ts</files>
  <action>
Add a second new method `findByIdBranchScoped` immediately after `findManyBranchScoped`.
This method uses `findFirst` (not `findUnique`) because `branchScopeWhere` adds an
additional WHERE condition that Prisma cannot use with `findUnique` (which requires
a unique column match only):

```typescript
async findByIdBranchScoped(id: string, user: RmsUserContext): Promise<RmaWithLines | null> {
  return this.prisma.rma.findFirst({
    where: {
      id,
      ...branchScopeWhere(user),
    },
    include: { lines: true },
  });
}
```

When the RMA does not exist OR belongs to a different branch, this returns `null`.
The controller will translate null → NotFoundException (404). This is intentional —
never reveal to the caller whether a record exists but is out of their scope.

No new imports needed. All required symbols are already in scope.
  </action>
  <verify>
    <automated>cd "C:/Users/megan.delia/OneDrive - Master Electronics/Desktop/Claude Workshop/rms-api" && npm run build 2>&1 | tail -5</automated>
  </verify>
  <done>
rma.repository.ts compiles with 0 TypeScript errors. The file contains both
"findManyBranchScoped" and "findByIdBranchScoped" as public async methods. The existing
findById() method is unchanged (still present, no modifications).
  </done>
</task>

</tasks>

<verification>
- `npm run build` exits 0 with no TypeScript errors
- `rma.repository.ts` contains `findManyBranchScoped` and `findByIdBranchScoped` methods
- Both new methods use `branchScopeWhere(user)` spread into the Prisma `where` clause
- `findByIdBranchScoped` uses `findFirst` (not `findUnique`) — this is correct and intentional
- Original `findById()` at line 20 is still present and unchanged
</verification>

<success_criteria>
- Two new branch-scoped repository methods are compilable and follow the established
  branchScopeWhere() pattern from findForApprovalQueue
- `findByIdBranchScoped` returns null for both missing and out-of-scope RMAs (security boundary)
- `npm run build` exits 0 — no TypeScript regressions
</success_criteria>

<output>
After completion, create `.planning/phases/03.5-lifecycle-http-controller/03.5-01-SUMMARY.md`
</output>
