---
phase: 03-workflow-and-line-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rms-api/prisma/schema.prisma
  - rms-api/src/rma/rma.types.ts
  - rms-api/src/rma/rma-lifecycle.ts
autonomous: true
requirements:
  - WKFL-02
  - WKFL-03
  - WKFL-04
  - WKFL-05
  - LINE-04

must_haves:
  truths:
    - "CONTESTED is a valid RmaStatus value in the database schema"
    - "RmaLine has financeApprovedAt, financeApprovedById, qcPass, qcFindings, qcDispositionRecommendation fields"
    - "Rma model has disputeReason, contestedAt, contestResolutionNote fields"
    - "ALLOWED_TRANSITIONS includes CONTESTED with two exit paths (APPROVED and CLOSED)"
    - "ContestInput, SplitLineInput, QcInspectionInput, ApproveLineCreditInput types exist in rma.types.ts"
    - "AuditAction includes RMA_CONTESTED and LINE_SPLIT constants"
    - "TypeScript build passes with zero errors after all changes"
  artifacts:
    - path: "rms-api/prisma/schema.prisma"
      provides: "CONTESTED enum value, Rma contest fields, RmaLine Finance/QC fields"
      contains: "CONTESTED"
    - path: "rms-api/src/rma/rma.types.ts"
      provides: "Input type contracts for Phase 3 service methods"
      exports: ["ContestInput", "SplitLineInput", "QcInspectionInput", "ApproveLineCreditInput", "ApprovalQueueItem"]
    - path: "rms-api/src/rma/rma-lifecycle.ts"
      provides: "State machine extended with CONTESTED paths"
      contains: "CONTESTED"
  key_links:
    - from: "rms-api/prisma/schema.prisma"
      to: "rms-api/src/rma/rma.types.ts"
      via: "Generated Prisma client exposes DispositionType enum used in QcInspectionInput"
      pattern: "DispositionType"
    - from: "rms-api/src/rma/rma-lifecycle.ts"
      to: "rms-api/src/rma/rma.service.ts"
      via: "ALLOWED_TRANSITIONS consumed by assertValidTransition()"
      pattern: "RmaStatus.CONTESTED"
---

<objective>
Extend the Prisma schema with Phase 3 database fields, add input type contracts to rma.types.ts, and extend the state machine transition map to include the CONTESTED state.

Purpose: Establish the data layer foundation that all Phase 3 service methods depend on. Schema must be migrated before service code can use new enum values or fields.
Output: Extended schema.prisma with CONTESTED enum + contest/finance/QC fields, updated rma.types.ts with all Phase 3 input contracts, extended rma-lifecycle.ts with CONTESTED transitions, and a generated migration file.
</objective>

<execution_context>
@C:/Users/megan.delia/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/megan.delia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-workflow-and-line-operations/03-CONTEXT.md
@.planning/phases/03-workflow-and-line-operations/03-RESEARCH.md

@.planning/phases/02-core-rma-lifecycle/02-02-SUMMARY.md
@.planning/phases/02-core-rma-lifecycle/02-03-SUMMARY.md

<interfaces>
<!-- Existing types the executor must know before writing new ones -->

From rms-api/src/rma/rma.types.ts (Phase 2 — extend this file, do not replace):
```typescript
export interface RmaActorContext { id: string; role: string; branchIds: string[]; }
export interface CreateRmaInput { customerId: string; branchId: string; lines: CreateLineInput[]; }
export interface CreateLineInput { partNumber: string; orderedQty: number; reasonCode: string; disposition?: DispositionType; }
export interface UpdateLineInput { partNumber?: string; orderedQty?: number; reasonCode?: string; disposition?: DispositionType | null; }
export interface SubmitRmaInput { /* empty — submission has no extra fields */ }
export interface RejectInput { rejectionReason: string; }
export interface CancelInput { cancellationReason: string; }
export interface RecordReceiptInput { lineId: string; receivedQty: number; }
export interface RecordQcInspectionInput { lineId: string; inspectedQty: number; }
```

From rms-api/src/rma/rma-lifecycle.ts (Phase 2 — extend ALLOWED_TRANSITIONS in-place):
```typescript
export const ALLOWED_TRANSITIONS: Readonly<Record<RmaStatus, readonly RmaStatus[]>> = {
  [RmaStatus.DRAFT]:         [RmaStatus.SUBMITTED, RmaStatus.CANCELLED],
  [RmaStatus.SUBMITTED]:     [RmaStatus.APPROVED, RmaStatus.REJECTED, RmaStatus.INFO_REQUIRED, RmaStatus.CANCELLED],
  [RmaStatus.INFO_REQUIRED]: [RmaStatus.SUBMITTED, RmaStatus.CANCELLED],
  [RmaStatus.APPROVED]:      [RmaStatus.RECEIVED, RmaStatus.CANCELLED],
  [RmaStatus.RECEIVED]:      [RmaStatus.QC_COMPLETE],
  [RmaStatus.QC_COMPLETE]:   [RmaStatus.RESOLVED],
  [RmaStatus.RESOLVED]:      [RmaStatus.CLOSED],
  [RmaStatus.REJECTED]:      [],
  [RmaStatus.CANCELLED]:     [],
  [RmaStatus.CLOSED]:        [],
};
```

From rms-api/prisma/schema.prisma (Phase 2 — CONTESTED must be added to enum, new fields to models):
```prisma
enum RmaStatus {
  DRAFT
  SUBMITTED
  INFO_REQUIRED
  APPROVED
  RECEIVED
  QC_COMPLETE
  RESOLVED
  CLOSED
  REJECTED
  CANCELLED
}

enum DispositionType {
  CREDIT
  REPLACEMENT
  SCRAP
  RTV
}
```

From rms-api/src/audit/audit.service.ts (AuditAction — add RMA_CONTESTED and LINE_SPLIT):
Existing actions include: RMA_CREATED, RMA_SUBMITTED, RMA_APPROVED, RMA_REJECTED,
RMA_INFO_REQUIRED, RMA_CANCELLED, RMA_RECEIVED, RMA_QC_COMPLETE, RMA_RESOLVED,
RMA_CLOSED, LINE_ADDED, LINE_UPDATED, DISPOSITION_SET.
AuditAction is a const object (not a Prisma enum) — add new keys directly in audit.service.ts or audit.types.ts.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Prisma schema with CONTESTED state and Phase 3 fields</name>
  <files>
    rms-api/prisma/schema.prisma
  </files>
  <action>
    Read the current rms-api/prisma/schema.prisma to get exact field ordering. Then make three additions:

    1. Add `CONTESTED` to the `RmaStatus` enum (after `CANCELLED`, before closing brace).

    2. Add three fields to the `Rma` model (after the existing `rejectionReason` field or near cancellation fields):
       - `disputeReason         String?`   — customer's dispute reason when contesting
       - `contestedAt           DateTime?` — timestamp of first contest; used for "one contest per RMA" guard
       - `contestResolutionNote String?`   — Branch Manager's documented note on overturn or uphold

    3. Add five fields to the `RmaLine` model (after the existing `qcInspectedAt` field):
       - `financeApprovedAt     DateTime?`      — when Finance approved this credit line
       - `financeApprovedById   String?`        — FK: User.id of Finance approver
       - `qcPass                Boolean?`       — true = pass, false = fail, null = not yet inspected
       - `qcFindings            String?`        — free-text QC findings/notes
       - `qcDispositionRecommendation DispositionType?` — QC staff's recommended disposition

    After editing schema.prisma, run:
    ```
    cd rms-api && npx prisma generate
    ```
    This regenerates the Prisma client so RmaStatus.CONTESTED and the new fields are available in TypeScript.

    NOTE: Do NOT run `prisma migrate dev` or `prisma db push` — Docker is not available in this execution environment. The migration will be run when Docker is available. Only `prisma generate` is needed to unblock TypeScript compilation.

    NOTE: Prisma 7 config: datasource URL lives in prisma.config.ts, NOT in schema.prisma. The schema.prisma datasource block uses `env("DATABASE_URL")` but the actual URL resolution uses the adapter pattern (PrismaPg) configured in prisma.config.ts. Do not add or remove datasource connection strings.
  </action>
  <verify>
    Run: `cd rms-api && npx prisma validate`
    Expected: "The schema at .../schema.prisma is valid!"

    Run: `cd rms-api && grep -n "CONTESTED\|disputeReason\|contestedAt\|contestResolutionNote\|financeApprovedAt\|qcPass\|qcFindings\|qcDispositionRecommendation" prisma/schema.prisma`
    Expected: All 8 terms found with line numbers.
  </verify>
  <done>schema.prisma validates cleanly, all 8 new fields/enum values present, prisma generate succeeds without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Add Phase 3 input contracts to rma.types.ts and extend rma-lifecycle.ts</name>
  <files>
    rms-api/src/rma/rma.types.ts
    rms-api/src/rma/rma-lifecycle.ts
    rms-api/src/audit/audit.service.ts
  </files>
  <action>
    **rma.types.ts — Append these new exported types (do not remove existing types):**

    ```typescript
    // Phase 3 input contracts

    export interface ContestInput {
      disputeReason: string;  // required; customer's dispute reason
    }

    export interface OverturnInput {
      resolutionNote: string;  // required; Branch Manager's documented note
    }

    export interface UpholdInput {
      resolutionNote: string;  // required; Branch Manager's documented note
    }

    export interface SplitLineInput {
      partNumber: string;
      orderedQty: number;        // positive integer; all splits must sum to original orderedQty
      reasonCode: string;
      disposition?: DispositionType;
    }

    // Extends RecordQcInspectionInput from Phase 2 — this is the new Phase 3 version
    // Replace or extend RecordQcInspectionInput to include structured QC result fields
    export interface RecordQcInspectionInput {
      lineId: string;
      inspectedQty: number;
      qcPass?: boolean;           // true = pass, false = fail
      qcFindings?: string;        // free-text inspection notes
      qcDispositionRecommendation?: DispositionType;  // QC staff recommendation
    }

    export interface ApproveLineCreditInput {
      // No extra fields needed — the actor context carries identity
    }

    // Approval queue response shape
    export interface ApprovalQueueItem {
      id: string;
      rmaNumber: string;
      status: string;              // RmaStatus (SUBMITTED or CONTESTED)
      createdAt: Date;
      customerId: string;
      submittedByName: string | null;
      submittedByEmail: string | null;
      lineCount: number;
      totalOrderedQty: number;
    }

    // Finance credit queue response shape
    export interface CreditApprovalQueueItem {
      rmaId: string;
      rmaNumber: string;
      lineId: string;
      partNumber: string;
      orderedQty: number;
      disposition: string;         // always 'CREDIT'
      rmaStatus: string;           // always 'QC_COMPLETE'
    }
    ```

    NOTE: If `RecordQcInspectionInput` already exists in rma.types.ts, replace it with the extended version above (add the three optional QC result fields while keeping `lineId` and `inspectedQty`).

    **rma-lifecycle.ts — Extend ALLOWED_TRANSITIONS:**

    Add `CONTESTED` to the transition map. The map must be an exhaustive record over ALL RmaStatus values including the new CONTESTED. Add:
    ```typescript
    [RmaStatus.CONTESTED]: [RmaStatus.APPROVED, RmaStatus.CLOSED],  // overturn | uphold
    ```

    Also add `CONTESTED` to any switch/exhaustiveness check in the file (if one exists) so TypeScript does not report unreachable cases.

    Additionally, update the REJECTED terminal entry from `[]` to remain `[]` — REJECTED is still terminal (CONTESTED is a separate state reached only from REJECTED; once upheld→CLOSED, no further contesting).

    **audit.service.ts (or audit.types.ts if AuditAction is defined there) — Add new action constants:**

    Find the AuditAction const object. Add:
    ```typescript
    RMA_CONTESTED: 'RMA_CONTESTED',
    LINE_SPLIT: 'LINE_SPLIT',
    FINANCE_APPROVED: 'FINANCE_APPROVED',
    ```

    Run TypeScript build to verify: `cd rms-api && npm run build`
    Expected: 0 errors.
  </action>
  <verify>
    Run: `cd rms-api && npm run build`
    Expected: exits 0, "Found 0 errors."

    Run: `cd rms-api && grep -n "CONTESTED\|ContestInput\|SplitLineInput\|ApprovalQueueItem\|RMA_CONTESTED\|LINE_SPLIT\|FINANCE_APPROVED" src/rma/rma.types.ts src/rma/rma-lifecycle.ts src/audit/audit.service.ts`
    Expected: All terms found across the three files.
  </verify>
  <done>TypeScript build passes with 0 errors. CONTESTED transition exists in ALLOWED_TRANSITIONS with [APPROVED, CLOSED] exits. All Phase 3 input type contracts exported from rma.types.ts. RMA_CONTESTED, LINE_SPLIT, FINANCE_APPROVED in AuditAction.</done>
</task>

</tasks>

<verification>
1. `cd rms-api && npx prisma validate` — schema valid
2. `cd rms-api && npm run build` — 0 TypeScript errors
3. `cd rms-api && grep "CONTESTED" prisma/schema.prisma src/rma/rma-lifecycle.ts` — appears in both
4. `cd rms-api && grep "financeApprovedAt\|qcPass\|disputeReason" prisma/schema.prisma` — all 3 field groups present
</verification>

<success_criteria>
- Prisma schema valid with CONTESTED enum value and all 8 new fields
- `prisma generate` succeeds (TypeScript client includes RmaStatus.CONTESTED)
- ALLOWED_TRANSITIONS includes `[RmaStatus.CONTESTED]: [RmaStatus.APPROVED, RmaStatus.CLOSED]`
- All Phase 3 input types exported from rma.types.ts
- AuditAction has RMA_CONTESTED, LINE_SPLIT, FINANCE_APPROVED
- `npm run build` exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/03-workflow-and-line-operations/03-01-SUMMARY.md`
</output>
