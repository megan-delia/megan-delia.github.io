generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// --- Identity & RBAC -------------------------------------------------------

model User {
  id           String   @id @default(uuid())
  portalUserId String   @unique  // portal JWT sub claim -- FK from host portal
  email        String   @unique
  displayName  String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  branchRoles   UserBranchRole[]
  auditEvents   AuditEvent[]      @relation("ActorAuditEvents")
  submittedRmas Rma[]             @relation("SubmittedRmas")
}

model Branch {
  id        String   @id @default(uuid())
  name      String
  code      String   @unique
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())

  branchRoles UserBranchRole[]
  rmas        Rma[]
}

// Junction table: one row per (user, branch, role) assignment
// A user can appear multiple times -- once per branch they are assigned to
model UserBranchRole {
  id         String   @id @default(uuid())
  userId     String
  branchId   String
  role       RmsRole
  assignedAt DateTime @default(now())
  assignedBy String   // portal user ID of Admin who granted this role

  user   User   @relation(fields: [userId], references: [id])
  branch Branch @relation(fields: [branchId], references: [id])

  @@unique([userId, branchId])  // one role per (user, branch) pair
  @@index([userId])
  @@index([branchId])
}

enum RmsRole {
  RETURNS_AGENT
  BRANCH_MANAGER
  WAREHOUSE
  QC
  FINANCE
  ADMIN
  CUSTOMER
}

// --- Audit Log -------------------------------------------------------------

// Append-only. Never UPDATE or DELETE rows. Written inside the same
// $transaction() as the state change it records.
model AuditEvent {
  id         String   @id @default(uuid())
  rmaId      String?  // nullable: non-RMA events (e.g. user provisioning)
  rmaLineId  String?  // nullable: line-level actions
  actorId    String   // FK -> User
  actorRole  String   // snapshot of role at event time (string for forward-compat)
  action     String   // AuditAction constant (stored as string for flexibility)
  fromStatus String?  // RMAStatus value for state transitions
  toStatus   String?
  oldValue   Json?    // JSONB: field-level before state
  newValue   Json?    // JSONB: field-level after state
  metadata   Json?    // JSONB: flexible extra context
  ipAddress  String?
  occurredAt DateTime @default(now())

  actor User  @relation("ActorAuditEvents", fields: [actorId], references: [id])
  rma   Rma?  @relation("RmaAuditEvents", fields: [rmaId], references: [id])

  @@index([rmaId])
  @@index([actorId])
  @@index([occurredAt])
}

// --- MERP Integration Log --------------------------------------------------

// Logs every call to the MERP adapter (stub or live) for reconciliation.
model MerpIntegrationLog {
  id              String   @id @default(uuid())
  rmaId           String
  operationType   String   // 'CREDIT_MEMO' | 'REPLACEMENT_ORDER'
  requestPayload  Json     // full payload sent (or would-be sent in stub)
  responsePayload Json?    // full MERP response
  referenceId     String?  // MERP-returned reference ID
  status          String   // 'STUB' | 'SUCCESS' | 'FAILED'
  errorMessage    String?
  calledAt        DateTime @default(now())

  @@index([rmaId])
}

// --- RMA Lifecycle ----------------------------------------------------------

enum RmaStatus {
  DRAFT
  SUBMITTED
  INFO_REQUIRED
  APPROVED
  RECEIVED
  QC_COMPLETE
  RESOLVED
  CLOSED
  REJECTED
  CANCELLED
}

enum DispositionType {
  CREDIT
  REPLACEMENT
  SCRAP
  RTV
}

// RMA number format: RMA-YYYYMM-NNNNNN (sequential per month)
model Rma {
  id                 String    @id @default(uuid())
  rmaNumber          String    @unique
  status             RmaStatus @default(DRAFT)
  branchId           String
  customerId         String?
  submittedById      String
  cancellationReason String?
  rejectionReason    String?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  submittedBy User         @relation("SubmittedRmas", fields: [submittedById], references: [id])
  branch      Branch       @relation(fields: [branchId], references: [id])
  lines       RmaLine[]
  auditEvents AuditEvent[] @relation("RmaAuditEvents")

  @@index([branchId])
  @@index([status])
  @@index([customerId])
  @@index([rmaNumber])
}

model RmaLine {
  id            String           @id @default(uuid())
  rmaId         String
  partNumber    String
  orderedQty    Int
  reasonCode    String
  disposition   DispositionType?
  receivedQty   Int              @default(0)
  inspectedQty  Int              @default(0)
  qcInspectedAt DateTime?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  rma Rma @relation(fields: [rmaId], references: [id], onDelete: Cascade)

  @@index([rmaId])
}
